1.5 / 6
# n = int(input())
# print(int(n * 1/6), int(n * 2/3), int(n * 1/6))

1.5 / 7
# Однажды, посетив магазин канцелярских товаров, Вася купил X карандашей, Y ручек и Z фломастеров.
# Известно, что цена ручки на 2 рубля больше цены карандаша и на 7 рублей меньше цены фломастера.
# Также известно, что стоимость карандаша составляет 3 рубля.
# Требуется определить общую стоимость покупки.
# x, y, z = map(int, input().split())
# print(3 * x + 5 * y + 12 * z)

1.5 / 8
# Известно, что на обработку одного квадратного метра панели требуется 1г сульфида.
# Всего необходимо обработать N прямоугольных панелей размером A на B метров.
# Вам необходимо подсчитать, сколько всего сульфида необходимо на обработку всех панелей.
# И не забудьте, что панели требуют обработки с обеих сторон.
# На вход программе подаются 3 положительных целых числа N,A,B
# print(*[2 * (x * y * z) for x, y, z in [map(int, input().split())]])

1.5 / 9
# Напишите программу, которая вычисляет средний балл ученика за решение четырех задач по введенным оценкам
# Оценки вводятся в одну строку, могут быть только целые числа от 2 до 5
# print(sum(map(int, input().split())) / 4)

1.5 / 10
# Программа на вход получает три целых числа:
#     часы, минуты, секунды, задающие первый момент времени и три целых числа, задающих второй момент времени.
# Определите, сколько секунд прошло между двумя моментами времени.
# H, M, S, H1, M2, S2 = int(input()), int(input()), int(input()), int(input()), int(input()), int(input())
# print((H1 * 3600 + M2 * 60 + S2) - (H * 3600 + M * 60 + S))
# print(sum([int(input()) * i for i in [-3600, -60, -1, 3600, 60, 1]]))

1.5 / 11
# Бандиты Гарри и Ларри отдыхали на природе.
# Решив пострелять, они выставили на бревно несколько банок из-под кока-колы (не больше 10).
# Гарри начал простреливать банки по порядку, начиная с самой левой, Ларри — с самой правой.
# В какой-то момент получилось так, что они одновременно прострелили одну и ту же последнюю банку.
# Гарри возмутился и сказал, что Ларри должен ему кучу денег за то,
# что тот лишил его удовольствия прострелить несколько банок.
# В ответ Ларри сказал, что Гарри должен ему еще больше денег по тем же причинам.
# Они стали спорить кто кому сколько должен, но никто из них не помнил сколько банок было в начале,
# а искать простреленные банки по всей округе было неохота.
# Каждый из них помнил только, сколько банок прострелил он сам.
# Определите по этим данным, сколько банок не прострелил Гарри и сколько банок не прострелил Ларри.
# G, L = map(int, input().split())
# print(L - 1, G - 1)

1.5 / 12
# Найдите результат выражения |a| + |b|
# print(abs(int(input())) + abs(int(input())))

1.5 / 3
# Напишите программу, которая вычисляет длину отрезка (т.е. расстояние между двумя точками),
# заданного двумя значениями x1 и x2 (вещественные числа).
# a, b = map(float, input().split())
# print(abs(a - b))

1.5 / 14
# Напишите программу, которая находит наилучшую оценку ученика за решение пяти контрольных работ.
# Оценки всех пяти работ вводятся в одну строку, могут быть только целые числа от 1 до 100
# print(max(map(int, input().split())))

1.5 / 15
# Во входных данных записаны три целых числа a, b и c, каждое в отдельной строке (1≤a,b,c≤10).
# Выведите максимальное значение выражения, которое можно получить.
# a, b, c = (int(input()) for _ in range(3))
# q, w, e, r, t, y = (a + b * c), (a * b + c), (a * (b + c)), ((a + b) * c), (a + b + c), (a * b * c)
# print(max(q, w, e, r, t, y))

1.5 / 16
# Вводится вещественное число и нам нужно его округлить до 2 и 3 разряда после запятой
# и вывести полученный результат через пробел в одной строчке
# n = float(input())
# print(round(n, 2), round(n, 3))

1.6 / 5
# Введите три числа и выведите их через запятую
# print(*input().split(), sep=',')

1.6 / 7
# a, b, c = (input() for _ in range(3))
# print(a, b, c, sep='---')
# print(*[input() for _ in range(3)], sep='---')

1.6 / 8
# print(*[i for i in range(1, 6)], sep=input())
# print(*range(1, 6), sep=input())

1.7 / 7
# print(sum(map(int,input())))

1.7 / 8
# У Олега в банке есть n евро. Он хочет снять всю сумму наличными. Номиналы еврокупюр равны 1, 5, 10, 20, 100.
# Какое минимальное число купюр должен получить Олег после того, как снимет все деньги?
# На вход программе поступает одно положительные целое число n.
# n = int(input())
# print(int(n // 100 + n % 100 // 20 + n % 20 // 10 + n % 10 // 5 + n % 5))
# n, s, lst = int(input()), 0, [100, 20, 10, 5, 1]
# for i in lst:
#     s += n // i
#     n %= i
# print(s)

1.7 / 9
# Дано число n. С начала суток прошло n минут.
# Определите, сколько часов и минут будут показывать электронные часы в этот момент.
# Программа должна вывести два числа: количество часов (от 0 до 23) и количество минут (от 0 до 59).
# Учтите, что число n может быть больше, чем количество минут в сутках.
# n = int(input())
# print((n // 60) % 24, n % 60)

1.7 / 9
# Дано целое число n. Выведите следующее за ним четное число.
# Задачу необходимо решить целочисленными операциями без использования условных операторов и\или циклов.
# print((int(input()) // 2 + 1) * 2)

1.7 / 10
# Электронные часы показывают время в формате h:mm:ss,
# то есть сначала записывается количество часов в диапазоне от 0 до 23,
# потом обязательно двузначное количество минут, затем обязательно двузначное количество секунд.
# Количество минут и секунд при необходимости дополняются до двузначного числа нулями.
# Программа получает на вход число n - количество секунд, которое прошло с начала суток.
# Выведите показания часов, соблюдая формат.
# n = int(input())
# H = (n // 3600) % 24
# M = (n // 60) % 60
# m1, m2 = str(M // 10), str(M % 10)
# S = n % 60
# s1, s2 = str(S // 10), str(S % 10)
# print(H, m1 + m2, s1 + s2, sep=':')

1.8 / 8
# Программа должна вывести True, если оба числа делятся на 7, в противном случае - False
# Сделать задачу необходимо без использования условного оператора.
# a, b = map(int, input().split())
# print(a % 7 == b % 7)

1.8 / 9
# Необходимо вывести True, если данные стороны образуют правильный треугольник, в противном случае - False.
# a, b, c = map(int, input().split())
# print(a == b == c)

1.8 / 15
# a, b, c = map(int, input().split())
# print(a == (b ** 2 + c ** 2) ** 0.5 or b == (a ** 2 + c ** 2) ** 0.5 or c == (b ** 2 + a ** 2) ** 0.5)

1.9 / 4
# from math import *
# print(ceil(int(input()) / 10))

1.9 / 5
# После вечеринки компания из N человек хочет добраться домой с помощью такси.
# Максимальное количество человек, которое может уместиться в машину равно 4.
# Сколько машин придется вызвать ребятам, чтобы все могли уехать?
# from math import ceil
# print(ceil(int(input()) / 4))

1.9 / 6
# В некоторой школе решили набрать три новых математических класса и оборудовать кабинеты для них новыми партами.
# За каждой партой может сидеть два учащихся. Известно количество учащихся в каждом из трех классов.
# Выведите наименьшее число парт, которое нужно приобрести для них.
# from math import ceil
# x, y, z = (int(input()) for _ in range(3))
# print(ceil(x / 2) + ceil(y / 2) + ceil(z / 2))
# print(sum([ceil(int(input()) / 2) for _ in range(3)]))

1.9 / 7
# Ваш дядя заинтересовался, сколько банок краски необходимо для покраски стен в офисе
# длиной L метров, шириной – W и высотой – H, если одной банки хватает на 16м2
# Заказов много, поэтому дядя попросил написать программу, которая будет все это считать.
# Программа получает на вход три натуральных числа L, W, H – длину, ширину и высоту офиса в метрах
# from math import ceil
# L, W, H = map(int, input().split())
# print(ceil((L + W) * H * 2 / 16))


2.1 / 12
# a, b, c = map(str, input().split())
# print('Simvol code', a, 'is', ord(a), end='.\n')
# print('Simvol code', b, 'is', ord(b), end='.\n')
# print('Simvol code', c, 'is', ord(c), end='.')
# [print(f'Simvol code {el} is {ord(el)}.') for el in input().split()]


2.3 / 13
# n = input().lower()
# m = n.replace('a', '').replace('o', '').replace('y', '').replace('e', '').replace('u', '').replace('i', '')
# print('.' + '.'.join(m))
# print(*("." + i for i in input().lower() if i not in "aoyeui"), sep="")


3.1 / 9
# Вы пользуетесь общественным транспортом? Вероятно, вы расплачивались за проезд и получали билет с номером.
# Счастливым билетом называют такой билет с шестизначным номером (иногда и с незначащими нулями),
# где сумма первых трех цифр равна сумме последних трех.
# Т.е. билеты с номерами 385916 и 2011 – счастливые, т.к. 3+8+5=9+1+6 и 0+0+2=0+1+1.
# Вам требуется написать программу, которая проверяет счастливость билета.
# n = [int(i) for i in input()]
# print(('NO', 'YES')[sum(n[:-3]) == sum(n[-3:])])
###################################
# s = str(input())
# if len(s) == 4:
#     s = '00' + s
# ticket = [int(x) for x in s]
# middle = len(ticket) // 2
# print('YES' if sum(ticket[0:middle]) == sum(ticket[middle:]) else 'NO')
###################################
# a = int(input())
# print("YES" if (a // 100000) + (a // 10000 % 10) + (a // 1000 % 10) == (a // 100 % 10) + (a // 10 % 10) + (
#             a % 10) else "NO")

3.1 / 10
# Напишите программу, которая на вход получает координаты двух клеток шахматной доски и выводит сообщение о том,
# являются ли эти клетки одного цвета.
# Столбцы на шахматной доске обозначаются английскими строчными буквами.
# Программа должна выводить YES, когда клетки одного цвета, NO - разного.
# Гарантируется, что значение колонок это латинские буквы abcdefgh, а строки это символы цифр от 1-8
# a, b, let = input(), input(), 'abcdefgh'
# print('YES' if (let.index(a[0]) + int(a[1])) % 2 == (let.index(b[0]) + int(b[1])) % 2 else 'NO')

3.1 / 11
# Для положительного целого числа n определим функцию f:
# f(5)=-1+2-3+4-5=-3
# Выведите f(n) в единственной строке.
# n = int(input())
# print(n // 2 if n % 2 == 0 else n // (-2))


3.2 / 2
# Вывести символ "<", если A меньше B, ">", если A больше B и "=", если A=B.
# a, b = int(input()), int(input())
# print('>' if a > b else '<' if a < b else '=')

3.2 / 3
# Даны три целых числа, каждое записано в отдельной строке.
# Нужно вывести значение наибольшего из данных чисел
# Примечание: используйте только условный оператор, функцией max пользоваться нельзя
# a, b, c = (int(input()) for _ in range(3))
# print(a if a > b and a > c else b if a < b and c < b else c)

3.2 / 4
# На свой день рождения Петя купил красивый и вкусный торт, который имел идеально круглую форму.
# Нужно разрезать торт на N равных частей.
# Следует учесть, что разрезы торта можно производить как по радиусу, так и по диаметру.
# Выведите минимально возможное число разрезов торта.
# n = int(input())
# print(0 if n == 1 else int(n) if n % 2 != 0 else int(n / 2))

3.2 / 5
# В отделе работают 3 сотрудника, которые получают заработную плату в рублях.
# Требуется определить: на сколько зарплата самого высокооплачиваемого из них отличается от самого низкооплачиваемого.
# Необходимо вывести одно целое число
# a, b, c = map(int, input().split())
# if a > b and a > c:
#     MAX = a
# elif b > a and b > c:
#     MAX = b
# else:
#     MAX = c
# if a < b and a < c:
#     MIN = a
# elif b < a and b < c:
#     MIN = b
# else:
#     MIN = c
# print(MAX - MIN)

3.2 / 6
# Его мама подарила Пете на день рождения две строки равной длины,
# состоящие из больших и маленьких букв латинского алфавита.
# Теперь Петя хочет сравнить эти строки лексикографически.
# Если первая строка меньше второй, выведите «-1».
# Если вторая строка меньше первой, выведите «1». Если строки равны, выведите «0».
# Учтите, что регистр букв не учитывается при сравнении.
# a, b = input().lower(), input().lower()
# print(0 if a == b else 1 if a > b else -1)

3.2 / 7
# Двое решили посоревноваться в набирании текстов на сайте «Кнопочные гонки».
# Во время соревнования необходимо ввести текст из s символов.
# Первый участник набирает один символ за v1 миллисекунд и имеет пинг t1 миллисекунд.
# Второй участник набирает один символ за v2 миллисекунд и имеет пинг t2 миллисекунд.
# Ровно через t миллисекунд после начала соревнования участник получает текст, который необходимо ввести.
# Ровно через t миллисекунд после того, как он перепечатал весь текст, сайт получает информацию об этом.
# Если выиграет первый участник, выведите «First». Если выиграет второй участник, выведите «Second».
# В случае ничьей выведите «Friendship».
# s - количество символов в тексте
# v1- скорость набора текста первым участником
# v2- скорость набора текста вторым участником
# t1- пинг первого участника
# t2- пинг второго участника
# s, v1, v2, t1, t2 = map(int, input().split())
# p1, p2 = (s * v1 + 2 * t1), (s * v2 + 2 * t2)
# print('First' if p1 > p2 else 'Second' if p1 < p2 else 'Friendship')

3.2 / 8
# При игре в "Города" игроки по очереди называют названия городов так,
# чтобы первая буква каждого нового слова совпадала с последней буквой предыдущего.
# При этом считают, что если последняя буква предыдущего слова — мягкий знак,
# то с первой буквой следующего слова надо сравнивать букву, предшествующую мягкому знаку.
# Напишите программу, которая считывает подряд две строки, после чего выводит «Good»,
# если последний символ первой строки совпадает с первым символом второй (с учётом правила про мягкий знак),
# и «Bad» в противном случае.
# s1, s2 = input().lower(), input().lower()
# if s1[-1] == s2[0]:
#     print('Good')
# elif s1[-1] == 'ь':
#     if s1[-2] == s2[0]:
#         print('Good')
# else:
#     print('Bad')


3.3 / 2
# Ваша программа должна считать одно натуральное число, после чего вывести:
# “Fizz”, если это число делится на 3;
# “Buzz”, если это число делится на 5;
# “FizzBuzz”, если выполнены оба предыдущих условия;
# само это число в остальных случаях.
# n = int(input())
# if n % 3 == 0 and n % 5 == 0:
#     print('FizzBuzz')
# elif n % 3 == 0:
#     print('Fizz')
# elif n % 5 == 0:
#     print('Buzz')
# else:
#     print(n)
#########################################
# m = input()
# n = int(m)
# print('Fizz' * (not n % 3) + 'Buzz' * (not n % 5) or m)

3.3 / 3
# Даны три целых числа, записанных в отдельных строках. Определите, сколько среди них совпадающих.
# Программа должна вывести одно из чисел: 3 (если все совпадают),
# 2 (если два совпадают) или 0 (если все числа различны).
# a, b, c = (int(input()) for _ in range(3))
# if a == b == c:
#     print(3)
# elif a != b and a != c and b != c:
#     print(0)
# else:
#     print(2)
#########################################
# abc = {input(), input(), input()}
# print(0 if len(abc) == 3 else 4 - len(abc))

3.3 / 4
# Программа определяет наименование месяца по его номеру n. Название месяца пишется с заглавной буквы
# Программа получает на вход номер месяца - натуральное число N (N<=12)
# и в зависимости от его значения вывод название месяца
# s = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
# 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']
# print(s[int(input())-1])
# print([0, 'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь',
# 'Октябрь', 'Ноябрь', 'Декабрь'][int(input())])

3.3 / 5
# Ваша программа получает на вход возраст человека. Вам необходимо вывести на экран сообщение:
# "Младенец", если возраст меньше 2х лет;
# "Малыш", если возраст от 2, но меньше 4;
# "Ребенок", если возраст от 4 лет, но меньше 12;
# "Подросток", когда возраст от 12 лет, но меньше 19;
# "Взрослый человек", когда возраст от 19 лет, но меньше 65;
# "Пожилой человек", если возраст 65 и более.
# n = int(input())
# if n < 2:
#     print("Младенец")
# elif 2 <= n < 4:
#     print("Малыш")
# elif 4 <= n < 12:
#     print("Ребенок")
# elif 12 <= n < 19:
#     print("Подросток")
# elif 19 <= n < 65:
#     print("Взрослый человек")
# else:
#     print("Пожилой человек")

3.3 / 6
# Необходимо посчитать значение операции «+», «-», «*», «/».
# Если ввели символ, который не относится к данным операциям, необходимо вывести «Неизвестно».
# «Неизвестно» также выводится при попытке деления на ноль
# a, b, z = float(input()), float(input()), input()
# if z in '+-*/':
#     if z == '+':
#         print(a + b)
#     elif z == '-':
#         print(a - b)
#     elif z == '*':
#         print(a * b)
#     elif z == '/':
#         if b != 0:
#             print(a / b)
#         else:
#             print('Неизвестно')
# else:
#     print('Неизвестно')

3.3 / 7
# Напишите программу, которая имитирует проверку пароля, придуманного пользователем.
# Пользователь сперва вводит пароль, потом вводит подтверждение пароля. Вам нужно обработать следующие ситуации:
# если пароль, который ввёл пользователь (в первый раз) короче 7 символов, программа выводит "Short"
# если пароль достаточно длинный, но введённый во второй раз пароль не совпадает с первым,
# программа выводит "Difference"
# если же и эта проверка пройдена успешно, программа выводит "OK" (латинскими буквами).
# p1, p2 = input(), input()
# if len(p1) > 7:
#     if p1 == p2:
#         print('OK')
#     else:
#         print('Difference')
# else:
#     print('Short')


4.1 / 8
# Мишка Лимак хочет стать самым большим медведем, ну, или хотя бы стать больше своего старшего брата Боба.
# Сейчас вес Лимака равен a, а вес Боба равен b. Гарантируется, что вес Лимака меньше или равен весу Боба.
# Лимак ест много, и его вес утраивается каждый год, а вес Боба удваивается каждый год.
# Через сколько целых лет Лимак станет строго больше (т. е. будет весить строго больше) Боба?
# В единственной строке находятся два целых числа a и b (1≤a≤b≤10) — веса Лимака и Боба соответственно.
# a, b = map(int, input().split())
# count = 0
# print(a, b)
# while a <= b:
#     count += 1
#     a *= 3
#     b *= 2
# print(count)

4.1 / 10
# На вход программе поступает слово.
# Вам необходимо воспроизвести процесс, в котором каждый раз у этого слово будет пропадать первая и последняя буква.
# Этот процесс необходимо закончить, когда в слове останется только одна буква или слово станет пустой строкой.
# При этом результат каждого этапа нужно выводить
# n = input()
# while len(n) > 0:
#     print(n)
#     n = n[1:-1]

4.1 / 11
# Выведите все точные квадраты натуральных чисел, не превосходящие данного числа N.
# Задано единственное целое число N
# Необходимо вывести  все точные квадраты натуральных чисел, не превосходящие данного числа N.
# n = int(input())
# m = 1
# while m ** 2 <= n:
#     print(m**2)
#     m += 1

4.1 / 12
# В первый день спортсмен пробежал X километров.
# В каждый последующий день он увеличивал пробег на 15% от предыдущего дня.
# Вам необходимо определить номер дня, в который пробег спортсмена составил не менее Y километров.
# Само число Y будем поступать на вход программе.
# Выведите целое число – номер дня, в который спортсмен пробежал не менее Y километров.
# a, b = map(int, input().split())
# d = 1
# while a <= b:
#     d += 1
#     a = a + a * 0.15
# print(d)

4.1 / 13
# У Васи есть n пар носков. Утром каждого дня, собираясь в школу, Вася должен надеть пару носков.
# Вечером, прийдя со школы, Вася снимает надетые носки и выбрасывает их.
# Каждый m-й день (в дни с номерами m,2m,3m,...) мама покупает Васе одну пару носков.
# Она делает это поздно вечером, поэтому Вася может надеть новые носки не раньше следующего дня.
# На сколько подряд идущих дней Васе хватит носков?
# Выведите единственное целое число — ответ на задачу.
# socks, days = map(int, input().split())
# day = 0
# while socks != 0:
#     day += 1
#     socks -= 1
#     if day % days == 0:
#         socks += 1
# print(day)

4.1 / 13
# Программист Василий любит романтику — поэтому на этот Новый Год он решил освещать свою комнату свечами.
# У Василия есть a свечей. Когда Василий зажигает новую свечу, сначала она горит ровно один час, а затем тухнет.
# Василий — сообразительный малый, поэтому из b потухших свечей он умеет получать одну новую свечу.
# В последствии эту новую свечу (так же как и другие новые свечи) можно зажечь.
# Теперь Василию интересно, на сколько часов освещения хватит его свечек, если он будет действовать оптимальным образом.
# Выведите единственное целое число — количество часов, которое Василий сможет освещать комнату.
# candle, bad = map(int, input().split())
# hours = 0
# while candle != 0:
#     candle -= 1
#     hours += 1
#     if hours % bad == 0:
#         candle += 1
# print(hours)

4.1 / 14
# В архитектуре компьютера важную роль играют числа, являющиеся степенями двойки: 1, 2, 4, 8 и так далее.
# Напишите программу, которая проверяет, является ли введённое натуральное число степенью двойки.
# Если да, то выводится сама эта степень; если нет, выводится «НЕТ»
# n, count = int(input()), 0
# while n % 2 == 0:
#     n /= 2
#     count += 1
# print(count if n == 1 else 'НЕТ')

4.1 / 15
# Возьмём число. Умножим его на его же первую цифру. Результат умножим на первую цифру результата.
# И так далее. Например, начнём с 8:
# 8→8∗8=64
# 64→6∗64=384
# 384→3∗384=1152
# 1152→1∗1152=1152
# Очевидно, когда первая цифра очередного числа в такой последовательности становится равной 1,
# числа перестают изменяться.
# Но это происходит не при всех начальных числах.
# Напишем программу, которая будет хотя бы приблизительно определять судьбу введённого числа n.
# Начиная с числа n, умножайте имеющееся число на его первую цифру,
# пока у получившегося числа первая цифра не станет равной 1,
# либо пока оно не превысит миллиарда. В качестве ответа выведите результат
# n = int(input())
# while int(str(n)[0]) != 1 and n < 1000000000:
#     n = n * int(str(n)[0])
# print(n)


4.2 / 2
# Пользователь вводит целые числа по одному в строке, последовательность оканчивается числом 0.
# Все, что вводится после 0 не относится к последовательности.
# Напишите программу, которая выводит сумму всех членов данной последовательности.
# n = int(input())
# z = 0
# while n != 0:
#     z += n
#     n = int(input())
# print(z)

4.2 / 3
# На каждой отдельной строчке пользователь вводит друг за другом пароли в виде строки символов.
# Валидными паролями будем считать строки, у которых длина варьируется от 5 до 9 символов включительно.
# Как только вы встретите первый невалидный пароль,
# ваша программа должна закончить считывать пароли и вывести последний введенный валидный пароль.
# Гарантируется, что первый пароль всегда валидный
# txt, zero = input(), ''
# while 4 < len(txt) < 10:
#     zero = txt
#     txt = input()
# print(zero)

4.2 / 4
# У нас в наличии рюкзак, вместимость которого составляет n литров,
# и наша задача забить его до предела максимально возможно.
# Нам поступают вещи, объем которых измеряется также в литрах,
# и мы должны их складывать в наш рюкзак без возможности пропуска.
# Как только суммарный объем новой добавляемой вещи превысит вместимость рюкзака,
# ваша программа должна вывести слово "Довольно!" и затем на отдельных строчках суммарный объем вещей,
# которые мы смогли упаковать в рюкзак, и их количество
# Строка "Довольно!" и затем два числа – суммарный объем упакованных товаров и их количество.
# Каждое значение выводится в отдельной строке.
# volume, s, v = int(input()), 0, 0
# while s <= volume:
#     objects = int(input())
#     s += objects
#     v += 1
# print('Довольно!', s - objects, v - 1, sep='\n')
##################################################
# n, r = int(input()), []
# while sum(r) <= n:
#     r.append(int(input()))
# print('Довольно!', sum(r[:-1]), len(r) - 1, sep='\n')

4.2 / 5
# tasks, time = map(int, input().split())
# task = 1
# while task <= tasks:
#     time += 5 * task
#     if time > 240:
#         time -= 5 * task
#         break
#     task += 1
# print(task - 1)
##################################################
# n, k = map(int, input().split())
# i = 0
# while 240 - k >= 0 and n >= i:
#     i += 1
#     k = k + i * 5
# print(i - 1)

4.2 / 6
# Ване на день рождения подарили n кубиков. Он с друзьями решил построить из них пирамиду.
# Ваня хочет построить пирамиду следующим образом:
# на верхушке пирамиды должен находиться 1 кубик,
# на втором уровне — 1+2=3 кубика, на третьем — 1+2+3=6 кубиков, и так далее.
# Таким образом, на i-м уровне пирамиды должно располагаться 1+2+...+(i-1)+i кубиков.
# Ваня хочет узнать, пирамиду какой максимальной высоты он может создать с использованием имеющихся кубиков.
# Выведите единственной строкой максимально возможную высоту пирамиды.
# n = int(input())
# lvl, s_lvl, s = 0, 0, 0
# while s < n:
#     lvl += 1
#     s_lvl += lvl
#     s += s_lvl
# if s == n:
#     print(lvl)
# else:
#     print(lvl - 1)
##################################################
# n = int(input())
# i = k = 1
# while n >= i:
#     n -= i
#     k += 1
#     i += k
# print(k - 1)

4.2 / 7
# В вашем распоряжении имеется два отсортированных списка по неубыванию элементов, состоящих из n и m элементов
# Ваша задача слить их в один отсортированный список размером  n + m
# Слить два списка в один в порядке неубывания и вывести элементы полученного списка
# n1, n2 = map(int, input().split())
# s1 = list(map(int, input().split()))
# s2 = list(map(int, input().split()))
# s3, z = s1 + s2, []
# while len(z) != n1 + n2:
#     z.append(min(s3))
#     s3.remove(min(s3))
# print(*z)

4.2 / 8
# По случаю 100500-летия Берляндского государственного университета совсем скоро состоится бал!
# Известно, что на бал будут приглашены несколько пар юноша-девушка,
# причем уровень умений танцевать партнеров в каждой паре должен отличаться не более чем на единицу.
# В первой строке записано целое число n (1≤n≤100) — количество юношей.
# Вторая строка содержит последовательность a1,a2,...,an (1≤ai≤100), где ai — умение танцевать i-го юноши.
# Аналогично, третья строка содержит целое m (1≤m≤100) – количество девушек.
# В четвертой строке содержится последовательность b1,b2,...,bm (1≤bj≤100), где bj — умение танцевать j-й девушки.
# Выведите единственное число — искомое максимальное возможное количество пар.
# m = int(input())
# ms = sorted(list(map(int, input().split())))
# w = int(input())
# ws = sorted(list(map(int, input().split())))
# count = 0
# for i in ms:
#     for j in range(count, len(ws)):
#         if i == ws[j] or i == ws[j] + 1 or i == ws[j] - 1:
#             count += 1
#             break
# print(count)
##################################################
# m = int(input())
# ms = sorted(list(map(int, input().split())))
# w = int(input())
# ws = sorted(list(map(int, input().split())))
# i1, i2 = 0, 0
# count = 0
# while i1 < m and i2 < w:
#     if abs(ws[i2] - ms[i1]) <= 1:
#         count += 1
#         i1 += 1
#         i2 += 1
#     elif ms[i1] < ws[i2]:
#         i1 += 1
#     else:
#         i2 += 1
# print(count)
##################################################
# m, y, w, x = [sorted([*map(int,input().split())]) for i in range(4)]
# for i in y:
#     for j in x:
#         if abs(i-j) <= 1:
#             x.remove(j)
#         break
# print(w[0]-len(x))


4.3 / 3
# Программа принимает на вход одно натуральное число и выводит его цифры в столбик в обратном порядке.
# n = int(input())
# while n > 0:
#     last = n % 10
#     n = n//10
#     print(last)
# print(*reversed(input()), sep='\n')

4.3 / 4
# Программа принимает на вход одно натуральное число и выводит на экран сумму цифр данного числа
# n, s = int(input()), 0
# while n > 0:
#     last = n % 10
#     n = n // 10
#     s += last
# print(s)
# print(sum([int(i) for i in input()]))

4.3 / 5
# Программа принимает на вход одно натуральное число и выводит на экран произведение цифр данного числа
# n, s = int(input()), 1
# while n > 0:
#     last = n % 10
#     n = n // 10
#     s *= last
# print(s)

4.3 / 6
# Программа принимает на вход одно натуральное число и выводит на экран минимальную
# и максимальную цифры данного числа в отдельных строчках
# n, MAX, MIN = int(input()), 0, 9
# while n > 0:
#     last = n % 10
#     n = n // 10
#     if last > MAX:
#         MAX = last
#     if last < MIN:
#         MIN = last
# print(MIN, MAX, sep='\n')

4.3 / 7
# Программа принимает на вход одно натуральное число. Ваша задачи найти сколько раз встречается цифра 7 в этом числе
# n, count = int(input()), 0
# while n > 0:
#     last = n % 10
#     n = n // 10
#     if last == 7:
#         count += 1
# print(count)

4.3 / 8
# Программа принимает на вход одно натуральное число и выводит его цифры
# в двоичной системе в столбик в обратном порядке.
# n = int(input())
# while n > 0:
#     last = n % 2
#     n = n // 2
#     print(last)


4.4 / 1
# Нахождение всех аей числа
# n, i, z = int(input()), 1, []
# while i * i < n:
#     if n % i == 0:
#         z.append(i)
#         if i != n // i:
#             z.append(n // i)
#     i += 1
# z.sort()
# print(z)

4.4 / 3
# Дано натуральное число N. Определить, является ли оно простым. Натуральное число N называется простым,
# если у него есть только два делителя: единица и само число N.
# В качестве ответа выведите "Yes", если число простое,  "No" - в противном случае.
# n, i, count = int(input()), 1, 0
# while i <= n:
#     if n % i == 0:
#         count += 1
#         if count > 2:
#             break
#     i += 1
# print('Yes' if count == 2 else 'No')

4.4 / 4
# Программа получает на вход натуральное число N. Нужно найти сумму его делителей.
# n, i, count = int(input()), 1, 0
# while i * i <= n:
#     if n % i == 0:
#         count += i
#         if i != n // i:
#             count += n // i
#     i += 1
# print(count)


4.5
# Алгоритм Евклида позволяет найти наибольший общий делитель (НОД) для двух чисел
# def Evklid(a, b):
#     while b > 0:
#         a, b = b, a % b
#     return a
# наименьшее общее кратное (НОК) = a * b / НОД
# a, b = (int(input()) for _ in range(2))
# c, d = a, b
# while b > 0:
#     a, b = b, a % b
# print(a)  # НОД
# print(c * d / a)  # НОК


4.6 / 4
# Программа получает на вход натуральное число n > 1. Выведите минимальный делитель этого числа, отличный от единицы.
# К примеру для числа 12 делителями являются 1, 2, 3, 4, 6, 12.
# n, d = int(input()), 2
# while n % d: d += 1
# print(d)
#######################################
# n, i = int(input()), 2
# while i <= n:
#     if n % i == 0:
#         print(i)
#         break
#     i += 1

4.6 / 5
# Давайте переберем все числа от а до b включительно и будем их выводить
# на экран, при этом нужно выполнить следующие условия:
# пропускать (не выводить) числа, которые делятся на 2 или на 3
# если встречаете число, кратное 777, необходимо принудительно закончить цикл, само это число не выводить
# Вывести все числа на интервале от a до b включительно
# a, b = int(input()), int(input()) + 1
# while a <= b:
#     if a == 777:
#         break
#     if a % 2 and a % 3:
#         print(a)
#     a += 1
#######################################
# a, b = int(input()), int(input())
# while a <= b:
#     if a % 777 == 0:
#         break
#     if a % 2 and a % 3:
#         print(a)
#     a += 1

4.6 / 6
# Сиракузская последовательность, или последовательность Коллатца, строится так:
# возьмём натуральное число n; если оно чётное, то заменим его числом n/2;
# если же оно нечётное, то заменим его числом 3n+1.
# Определите, сколько шагов потребуется сиракузской последовательности, стартующей с заданного числа, чтобы прийти к 1.
# 8 → 4 → 2 → 1 или 10 → 5 → 16 → 8 → 4 → 2 → 1.
# Определите, сколько шагов потребуется сиракузской последовательности, стартующей с заданного числа, чтобы прийти к 1.
# Выводится одно число — количество шагов, необходимое стартующей
# от n сиракузской последовательности, чтобы впервые дойти до 1.
# n, count = int(input()), 0
# while n != 1:
#     n = n // 2 if n % 2 == 0 else 3 * n + 1
#     count += 1
# print(count)

4.6 / 10
# Вам на вход поступает слово и ваша задача в цикле while обойти все его буквы и распечатать их в формате фразы:
# «Текущая буква: <letter>».
# Как только вы встретите строчные английские буквы «e» или «a» нужно вывести фразу «Ага! Нашлась»,
# перестать печатать буквы и принудительно выйти из цикла.
# В случае, если в слове не оказалось букв «e» или «a» необходимо вывести фразу «Распечатали все буквы»
# word, i = input(), 0
# while i != len(word):
#     if word[i] == 'e' or word[i] == 'a':
#         print('Ага! Нашлась')
#         break
#     else:
#         print('Текущая буква:', word[i])
#     i += 1
# else:
#     print("Распечатали все буквы")


5.2 / 6
# Напишите программу, которая считывает два натуральных числа a и b (гарантируется, что a<b),
# после чего для всех чисел от a до b включительно выводит:
# “Fizz”, если это число делится на 3;
# “Buzz”, если это число делится на 5;
# “FizzBuzz”, если выполнены оба предыдущих условия;
# само это число в остальных случаях.
# a, b = (int(input()) for _ in range(2))
# for i in range(a, b + 1):
#     if i % 3 == 0 and i % 5 == 0:
#         print('FizzBuzz')
#     elif i % 5 == 0:
#         print('Buzz')
#     elif i % 3 == 0:
#         print('Fizz')
#     else:
#         print(i)
#######################################
# for n in range(int(input()), int(input()) + 1):
#     print('Fizz' * (not n % 3) + 'Buzz' * (not n % 5) or n)

5.2 / 7
# На вход программе подается два натуральных числа a и b (гарантируется, что a<b),
# после чего для каждого целого числа на интервале от a до b включительно необходимо вывести фразу следующего вида:
# «Число {число}; его квадрат = {квадрат}; его куб = {куб}»
# Кавычки выводить не нужно и пользуйтесь f-строкой.
# for i in range(int(input()), int(input()) + 1):
#     print(f'Число {i}; его квадрат = {i * i}; его куб = {i ** 3}')

5.2 / 8
# Сначала определяется значение n — количество раундов игры.
# В очередном раунде каждый из игроков один раз бросает стандартный игральный кубик.
# В самой же игре побеждает участник, выигравший в большем количестве раундов.
# Если же количества побед, заслуженных игроками, равны, то объявляется ничья.
# В случае победы Мишки в единственной строке выведите "Mishka" (без кавычек),
# а в случае победы Криса выведите "Chris" (без кавычек). Если же игра сведётся к ничьей,
# то выведите "Friendship is magic!^^" (без кавычек).
# Bear, Chris = 0, 0
# for i in range(int(input())):
#     s = input().split()
#     if s[0] > s[1]:
#         Bear += 1
#     elif s[0] < s[1]:
#         Chris += 1
# print('Mishka' if Bear > Chris else 'Chris' if Bear < Chris else 'Friendship is magic!^^')

5.2 / 9
# Найдите, в каких строках из введённых и в каком месте упоминается "рок", причем регистр букв не важен.
# Вместо явного цикла прохода по строке в цикле используйте подходящий метод строки.
# Для каждой строки, в которой есть сочетание символов «рок», нужно вывести (в порядке появления таких строк)
# номер этой строки (нумерация начинается с единицы) и номер символа, с которого начинается первое вхождение
# этой подстроки (нумерация символов также с единицы).
# string, n_letter = 0, 0
# for i in range(int(input())):
#     word = input().lower()
#     if 'рок' in word:
#         print(i + 1, word.index('рок') + 1)

5.2 / 10
# На первой строке вводится натуральное число N — количество пунктов рецепта.
# Далее следуют N строк — пункты рецепта.
# Одна строка — пункты рецепта, разделённые запятой и пробелом, без пунктов с упоминанием слова
# "соль" (то есть таких, в которых нет подстроки "соль" в нижнем регистре).
# s = []
# for i in range(int(input())):
#     ingredients = input()
#     if 'соль' in ingredients:
#         continue
#     s.append(ingredients)
# print(*s, sep=', ')

5.2 / 11
# Если перечислить все натуральные числа ниже 10, которые кратны 3 или 5, то получим 3, 5, 6 и 9. Сумма этих чисел 23.
# Напишите программу, которая принимает натуральное число n и находит сумму всех чисел ниже переданного числа n,
# которые делятся на 3 или на 5.
# s = 0
# for i in range(int(input())):
#     if i % 3 == 0:
#         s += i
#     elif i % 5 == 0:
#         s += i
# print(s)
######################################
# print(sum(i for i in range(int(input())) if not i % 3 or not i % 5))
#######################################
# num = int(input())
# print(sum(range(3, num, 3)) + sum(range(5, num, 5)) - sum(range(15, num, 15)))

5.2 / 12
# Напишите программу, которая найдет сумму кубов натуральных чисел от 50 до 100 включительно
# print(sum(i**3 for i in range(50, 101)))

5.2 / 13
# Иногда некоторые слова вроде «civilization» или «internationalization» настолько длинны,
# что их весьма утомительно писать много раз в каком либо тексте.
# Будем считать слово слишком длинным, если его длина строго больше 10 символов.
# Все слишком длинные слова можно заменить специальной аббревиатурой.
# Эта аббревиатура строится следующим образом: записывается первая и последняя буква слова,
# а между ними — количество букв между первой и последней буквой (в десятичной системе счисления и без ведущих нулей).
# Таком образом, «civilization» запишется как «c10n», а «internationalization» как «i18n».
# for i in range(int(input())):
#     word = input().lower()
#     print(word[0] + str(len(word) - 2) + word[-1] if len(word) > 10 else word)


5.3 / 3
# На первой строке вводится один символ — строчная буква.
# На второй строке вводится предложение.
# Нужно вывести список слов (словом считается часть предложения, окружённая символами пустого пространства),
# в которых присутствует введённая буква в любом регистре, в том же порядке, в каком они встречаются в предложении.
# letter = input()
# txt = input().split()
# for i in txt:
#     if letter in i:
#         print(i)

5.3 / 4
# На вход программе поступает список из целых чисел. Ваша задача найти в данном списке наименьшее
# положительное значение. В случае, если положительных значений нет, выведите строку "Empty"
# s, z = map(int, input().split()), []
# for i in s:
#     if i > 0:
#         z.append(i)
# if len(z) > 0:
#     z.sort()
#     print(z[0])
# else:
#     print('Empty')

5.3 / 5
# Напишите программу, которая находит рекордное количество вхождений (не обязательно подряд) символа в строку.
# string, z = input().lower(), []
# for i in string:
#     z.append(string.count(i))
# print(max(z))
#######################################
# word = input().lower()
# print(max([word.count(i) for i in word]))

5.3 / 6
# Для делимости числа на 11 необходимо, чтобы разность между суммой цифр, стоящих на четных местах,
# и суммой цифр, стоящих на нечетных местах, делилась на 11.
# Требуется написать программу, которая проверит делимость заданного числа на 11.
# Выведите “YES”, если число делится на 11, или “NO” иначе.
# n, chet, nechet = input(), 0, 0
# for i in range(len(n)):
#     if i % 2:
#         chet += int(n[i])
#     else:
#         nechet += int(n[i])
# print('YES' if not abs(nechet - chet) % 11 else 'NO')
#######################################
# n = [int(i) for i in input()]
# print('NO' if (sum(n[1::2]) - sum(n[0::2])) % 11 else 'YES')

5.3 / 7
# На вход программе поддается строка, а ваша задача определить сколько символов в данной строке являются цифрами
# и также найти сумму всех этих цифр. Например, в строке "Комната 1408" содержится 4 цифры и их сумма равна 13.
# В качестве ответа необходимо через пробел вывести 2 числа - количество цифр в введенной строке и их сумма
# count, summ = 0, 0
# for i in input():
#     if i.isdigit():
#         count += 1
#         summ += int(i)
# print(count, summ)
#######################################
# [print(len(s), sum(s)) for s in [[int(i) for i in input() if i.isdigit()]]]

5.3 / 8
# Наша программа принимает на вход последовательность скобочных символов. Ваша задача определить является ли
# введенная скобочная последовательность правильной.
# Правильная скобочная последовательность (ПСП) называется строка, состоящая только из символов "скобки",
# где каждой закрывающей скобке найдётся соответствующая открывающая (причём того же типа). При этом учитывайте, что:
# Пустая последовательность является правильной.
# Если A – правильная скобочная последовательность, то (A), [A] и {A} – правильные скобочные последовательности.
# Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
# Если введенная строка является ПСП, выведите YES, в противном случае - NO.


# Берётся стек - пустой список, если скобка открывающаяся то записываем ее в стек, если скобка закрывающаяся
# то проверяем последнюю скобку в нашем стеке, если они вместе создадут пару ( ) { } [ ],
# то удаляем открывающуюся скобку в стеке, то-есть последний элемент стека. Это позволит не задевать наш основной
# список и не выйти за список случайно в случае если бы вы удаляли прям в нашем списке.
# Сложность такого алгоритма уже О(n)
# n = input()  #Слишком долго выполняется
# if n[0] not in ']})' and len(n) % 2 == 0:
#     while "()" in n or "[]" in n or "{}" in n:
#         n = n.replace('[]', '')
#         n = n.replace('()', '')
#         n = n.replace('{}', '')
#     if len(n) == 0:
#         print("YES")
#     else:
#         print("NO")
# else:
#     print('NO')
#######################################
# brackets, s, flag = input(), [], True
# for el in brackets:
#     if el in '[{(':
#         s.append(el)
#     elif el in ']})':
#         if len(s) == 0:
#             flag = False
#             break
#
#         last = s.pop()
#         if last == '(' and el == ')':
#             continue
#         if last == '[' and el == ']':
#             continue
#         if last == '{' and el == '}':
#             continue
#
#         flag = False
#         break
# if flag and len(s) == 0:
#     print("YES")
# else:
#     print("NO")
#######################################
# pattern = input()
# for i in range(len(pattern) // 2):
#     pattern = pattern.replace('{}', '')
#     pattern = pattern.replace('()', '')
#     pattern = pattern.replace('[]', '')
# print('YES' if len(pattern) == 0 else 'NO')
#######################################


5.4 / 2
# На вход вашей программе поступает положительное целое число n, а ваша задача вывести в порядке возрастания
# все цифры, которые встречались в этом числе, и напротив каждого также необходимо
# вывести сколько раз данная цифра встречалась в числе n
# n = input()
# counter = [0] * 10
# for i in n:
#     counter[int(i)] += 1
# for i in range(10):
#     if counter[int(i)] > 0:
#         print(str(i), counter[i])

5.4 / 3
# Как видно из названия задачи, вам необходимо отсортировать список, состоящий только из чисел в пределах от -100
# до 100 включительно, сортировкой подсчетом.
# Программа получает на вход число n - количество элементов в списке, затем сами элементы списка
# Вам необходимо вывести отсортированный список
# n, a = int(input()), []
# s = list(map(int, input().split()))
# while len(s) != 0:
#     a.append(min(s))
#     s.remove(min(s))
# print(*a)


5.5 / 2
# Найдите сумму всех четырехзначных чисел, сумма цифр каждого из которых равна 20.
# total = 0
# for i in range(1000, 10000):
#     if sum(map(int, str(i))) == 20:
#         total += i
# print(total)
##############################################
# print(sum(i for i in range(1000, 10000) if sum(int(j) for j in str(i)) == 20))

5.5 / 3
# В этой задаче вам предстоит построить лесенку из чисел. Программа принимает на вход целое положительное
# число n (n<=15), ваша задача вывести n уровней, в каждом из которых стоят числа от 1 до значения уровня.
# for i in range(1, int(input()) + 1):
#     for j in range(1, i + 1):
#         print(j, end=' ')
#     print()

5.5 / 4
# Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, что для любого n > 1
# найдется простое число p в интервале n < p < 2n. Такая гипотеза была выдвинута в 1845 году
# французским математиком Джозефем Бертраном (проверившим ее до n=3000000) и доказана в 1850 году Пафнутием Чебышевым.
# Рамануджан в 1920 году нашел более простое доказательство, а Эрдеш в 1932 – еще более простое.
# Ваша задача состоит в том, чтобы решить несколько более общую задачу – а именно по числу n найти количество простых
# чисел p из интервала n < p < 2n.
# Напомним, что число называется простым, если оно делится только само на себя и на единицу.
# def good_number(i):
#     if i % 2 == 0 and i != 2 or i == 1:
#         return False
#     number = 3
#     while number * number <= i:
#         if i % number == 0:
#             return False
#         number += 2
#     return True
#
#
# n, counter = int(input()), 0
# for i in range(n + 1, n * 2):
#     if good_number(i):
#         counter += 1
# print(counter)
##############################################
# n, a = int(input()), 0
# for i in range(n + 1, n * 2):
#     for j in range(2, int(i ** 0.5) + 1):
#         if i % j == 0:
#             break
#     else:
#         a += 1
# print(a)

5.5 / 5
# Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает.
# Но теперь Фурик хочет получить хорошую оценку по математике. Для этого Лариса Ивановна, учительница математики,
# дала ему новое задание. Фурик сразу же решил эту задачу, а вы сможете?
# Задана система уравнений:
# a ** 2 + b = n
# a + b ** 2 = m
# Нужно посчитать количество пар целых чисел (a,b) (0≤a,b), которые удовлетворяют системе.

# n, m = map(int, input().split())
# a = max(n, m)
# counter = 0
# for i in range(int(a ** 0.5) + 1):
#     for j in range(int(a ** 0.5) + 1):
#         if i ** 2 + j == n and j ** 2 + i == m:
#             counter += 1
# print(counter)
##############################################
# # import time
# # start_time = time.time()
# n, m = map(int, input().split())
# a = max(n, m)
# b = min(n, m)
# c = 0
# counter = 0
# if int(a ** 0.5) <= b:
#     c = b
# else:
#     c = a
# print(c)
# for i in range(c + 1):
#     for j in range(c + 1):
#         if i ** 2 + j == n and j ** 2 + i == m:
#             counter += 1
# print(counter)
# # print(f"{(time.time() - start_time)*1000} миллисекунд")

5.5 / 6
# Напишите программу для построения горизонтальных столбчатых диаграмм с помощью символа звёздочки.
# Несколько натуральных чисел на одной строке.

# print(*['*' * int(i) for i in input().split()], sep='\n')

5.5 / 7
# Сортировка пузырьком

# Поступает число n - количество элементов в списке, и затем сам список.
# Ваша задача отсортировать список по возрастанию при помощи пузырьковой сортировки,
# в случае если элементы соседние совпадают менять их ненужно.
# В качестве ответа нужно вывести отсортированный список и какое количество
# раз пришлось переставлять элементы в процессе сортировки

# n, count = int(input()), 0
# s = list(map(int, input().split()))
# for i in range(n - 1):
#     for j in range(n - 1 - i):
#         if s[j] > s[j + 1]:
#             s[j], s[j + 1] = s[j + 1], s[j]
#             count += 1
#         else:
#             break
# print(*s)
# print(count)

5.5 / 8
# Сортировка вставками

# Программа получает на вход число n - количество элементов в списке, и затем в следующей строке сам список.
# Ваша задача отсортировать список по возрастанию при помощи сортировки вставками,
# в случае если элементы соседние совпадают менять их ненужно.
# В качестве ответа нужно вывести отсортированный список.

# n = int(input())
# s = list(map(int, input().split()))
# for i in range(1, n):
#     for j in range(i, 0, -1):
#         if s[j] < s[j - 1]:
#             s[j], s[j - 1] = s[j - 1], s[j]
#         else:
#             break
# print(*s)


5.6 / 2
# Вам нужно посчитать сумму элементов двумерного квадратного (NxN) списка, которые расположены на главной диагонали.
# Под главной диагональю матрицы подразумевается диагональ, проведённая из левого верхнего угла в правый нижний.
# Программа сперва принимает на вход число N (N<=15) - количество строк и столбцов в списке,
# а затем в N строках записаны элементы списка.

# n, b, s = int(input()), [], 0
# for i in range(n):
#     b.append(list(map(int, input().split())))
# for i in range(len(b)):
#     s += b[i][i]
# print(s)
##############################################
# s = 0
# b = [list(map(int, input().split())) for _ in range(int(input()))]
# for i in range(len(b)):
#     s += b[i][i]
# print(s)

5.6 / 3
# Задана целочисленная квадратная матрица размером N x N. Необходимо обойти элементы этой матрицы сверху
# вниз слева направо и вывести элементы именно в таком порядке в виде таблицы.
# Программа принимает на вход натуральное число N – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны N целых чисел – элементы матрицы. Все числа во входных данных
# не превышают 100 по абсолютной величине.

# b = [list(map(int, input().split())) for i in range(int(input()))]
# for i in range(len(b)):
#     for j in range(len(b)):
#         print(b[j][i], end=' ')
#     print()

5.6 / 4
# Обход элементов матрицы - 2

# Задана целочисленная квадратная матрица размером N x N. Необходимо обойти элементы этой матрицы снизу
# вверх справо налево и вывести элементы именно в таком порядке в виде таблицы.
# Программа принимает на вход натуральное число N – количество строк и столбцов матрицы. В каждой из последующих
# N строк записаны N целых чисел – элементы матрицы.

# b = [list(map(int, input().split())) for i in range(int(input()))]
# for i in range(len(b) - 1, -1, -1):
#     for j in range(len(b) - 1, -1, -1):
#         print(b[j][i], end=' ')
#     print()

5.6 / 5
# Обход элементов матрицы - 3

# Задана целочисленная матрица, состоящая из N строк и M столбцов. Необходимо обойти элементы этой матрицы
# cправо налево сверху вниз, и вывести элементы именно в таком порядке в виде таблицы.
# Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны M целых чисел – элементы матрицы.

# n, m = map(int, input().split())
# b = [list(map(int, input().split())) for i in range(n)]
# for i in range(len(b)):
#     for j in range(m - 1, -1, -1):
#         print(b[i][j], end=' ')
#     print()

5.6 / 6
# Обход элементов матрицы - 4

# Задана целочисленная матрица, состоящая из N строк и M столбцов. Необходимо обойти элементы
# этой матрицы слева направо снизу вверх, и вывести элементы именно в таком порядке в виде таблицы.
# Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы.
# В каждой из последующих N строк записаны M целых чисел – элементы матрицы.

# n, m = map(int, input().split())
# b = [list(map(int, input().split())) for i in range(n)]
# for i in range(len(b) - 1, -1, -1):
#     for j in range(m):
#         print(b[i][j], end=' ')
#     print()

5.6 / 7
# Красивая матрица

# Перед Вами матрица размера 5×5, состоящая из 24-x нулей и единственной единицы. Строки матрицы пронумеруем числами
# от 1 до 5 сверху вниз, столбцы матрицы пронумеруем числами от 1 до 5 слева направо.
# За один ход разрешается применить к матрице одно из двух следующих преобразований:
# Поменять местами две соседние строки матрицы, то есть строки с номерами i и i+1 для некоторого целого i (1≤i<5).
# Поменять местами два соседних столбца матрицы, то есть столбцы с номерами j и j+1 для некоторого целого j (1≤j<5).
# Вы считаете, что матрица будет выглядеть красиво, если единственная единица этой матрицы будет находиться в ее центре
# (в клетке, которая находится на пересечении третьей строки и третьего столбца).
# Посчитайте, какое минимальное количество ходов потребуется, чтобы сделать матрицу красивой.
# Гарантируется, что матрица состоит из 24-x нулей и единственной единицы.
# Выведите целое число — минимальное количество действий, которое требуется, чтобы сделать матрицу красивой.

# b = [list(map(int, input().split())) for i in range(5)]
# line, column, count = 0, 0, 0
# for i in b:
#     for j in i:
#         if j == 1:
#             line = b.index(i)
#             column = i.index(j)
# while line != 2:
#     if line < 2:
#         count += 1
#         line += 1
#     elif line > 2:
#         count += 1
#         line -= 1
#
# while column != 2:
#     if column < 2:
#         count += 1
#         column += 1
#     elif column > 2:
#         count += 1
#         column -= 1
# print(count)

5.6 / 8
# Сумма строк и столбцов двумерного массива

# Задан целочисленный двумерный массив, состоящий из N строк и M столбцов.
# Требуется вычислить сумму элементов в каждой строке и в каждом столбце.
# Программа получает на вход два натуральных числа N и M – количество строк и столбцов двумерного массива.
# В каждой из последующих N строк записаны M целых чисел – элементы массива.#
# В первой строке вам необходимо вывести N чисел – суммы элементов массива для каждой строки в отдельности.
# Во второй строке в аналогичном формате выведите M чисел – суммы элементов для каждого столбца.

# n, m = map(int, input().split())
# b = [list(map(int, input().split())) for i in range(n)]
# for i in b:
#     print(sum(i), end=' ')
# print()
# for j in range(m):
#     s = 0
#     for i in range(n):
#         s += b[i][j]
#     print(s, end=' ')
##############################################
# n, m = map(int, input().split())
# s = [list(map(int, input().split())) for i in range(n)]
# print(*[sum(s[i][j] for j in range(m)) for i in range(n)])
# print(*[sum(s[i][j] for i in range(n)) for j in range(m)])
##############################################
# row, col = map(int, input().split())
# matrix = [list(map(int, input().split())) for row in range(row)]
# for row in matrix:
# 	print(sum(row), end=' ')
# print()
# for x in range(col):
# 	print(sum([row[x] for row in matrix]), end=' ')

5.6 / 9
# Симметричная ли матрица?

# Проверьте, является ли двумерный массив симметричным относительно главной диагонали.
# Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний.
# Программа получает на вход число n<100, являющееся числом строк и столбцов в массиве. Далее во входном потоке
# идет n строк по n чисел, являющихся элементами массива.
# Программа должна выводить слово Yes для симметричного массива и слово No для несимметричного.

# b = [list(map(int, input().split())) for i in range(int(input()))]
# flag = 'Yes'
# for j in range(len(b)):
#     for i in range(len(b)):
#         if b[i][j] != b[j][i]:
#             flag = 'No'
# print(flag)

5.6 / 10
# Состязания

# В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победителем считается тот спортсмен,
# у которого сумма результатов по всем броскам максимальна.
# Если перенумеровать спортсменов числами от 0 до n-1, а попытки каждого из них – от 0 до m-1, то на вход программа
# получает массив A[n][m], состоящий из неотрицательных целых чисел. Программа должна определить максимальную сумму
# чисел в одной строке и вывести на экран эту сумму и номер строки, для которой достигается эта сумма.
# Программа должна вывести 2 числа: сумму и номер строки, для которой эта сумма достигается. Если таких строк
# несколько, то выводится номер наименьшей из них. Не забудьте, что нумерация строк (спортсменов) начинается с 0.

# n, m = map(int, input().split())
# b = [list(map(int, input().split())) for i in range(n)]
# z = [sum(i) for i in b]
# print(max(z), z.index(max(z)), sep='\n')
##############################################
# rows, cols = map(int, input().split())
# matrix = [list(map(int, input().split())) for row in range(rows)]
# answer = list(map(sum, matrix))
# print(max(answer), answer.index(max(answer)), sep='\n')

5.6 / 11
# Состязания - 2

# В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победителем соревнований объявляется
# тот спортсмен, у которого максимален наилучший результат по всем броскам. Таким образом, программа должна найти
# значение максимального элемента в данном массиве, а также его индексы (то есть номер спортсмена и номер попытки).
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке
# идет n строк по m чисел, являющихся элементами массива.
# Программа выводит значение максимального элемента, затем номер строки и номер столбца, в котором он встречается.
# Если в массиве несколько максимальных элементов, то нужно вывести минимальный номер строки, в которой встречается
# такой элемент, а если в этой строке таких элементов несколько, то нужно вывести минимальный номер столбца.

# n, m = map(int, input().split())
# b = [list(map(int, input().split())) for i in range(n)]
# z, x, y, MAX = [], 0, 0, 0
# for i in range(n):
#     for j in range(m):
#         if b[i][j] > MAX:
#             MAX = b[i][j]
#             x, y = i, j
# print(f'{MAX}\n{x} {y}')
##############################################
# n, m = map(int, input().split())
# a = [list(map(int, input().split())) for i in range(n)]
# b = [max(i) for i in a]
# print(max(b))
# print(b.index(max(b)), a[b.index(max(b))].index(max(b)))

5.6 / 11
# Состязания - 3

# В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Побеждает спортсмен, у которого
# максимален наилучший бросок. Если таких несколько, то из них побеждает тот, у которого наилучшая сумма результатов
# по всем попыткам. Если и таких несколько, победителем считается спортсмен с минимальным номером. Определите номер
# победителя соревнований.
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке
# идет n строк по m чисел, являющихся элементами массива.

# НЕ РАБОТАЕТ ПОЧЕМУ-ТО
# n, m = map(int, input().split())
# a = [list(map(int, input().split())) for i in range(n)]
# b, count = [max(i) for i in a], 0
# for i in b:
#     if i < max(b):
#         a[b.index(i)] = [0]
# for i in b:
#     if b.count(max(b)) == 1:
#         count = b.index(max(b))
#     else:
#         c = [sum(i) for i in a]
#         count = c.index(max(c))
# print(count)
################################################
# n, m = map(int, input().split())
# MAXr, INDEXs, SUMi = 0, 0, 0
# for j in range(n):
#     a = list(map(int, input().split()))
#     for b in range(m):
#         if a[b] > MAXr or (a[b] == MAXr and sum(a) > INDEXs):
#             MAXr, SUMi, INDEXs = a[b], j, sum(a)
# print(SUMi)
################################################
# n, m = map(int, input().split())
# a, b = [list(map(int, input().split())) for i in range(n)], []
# for i in range(n):
#     b.append([max(a[i]), sum(a[i])])
# print(b.index(max(b)))

5.6 / 12
# Состязания - 4

# В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победитель определяется по лучшему
# результату. Определите количество участников состязаний, которые разделили первое место, то есть определите
# количество строк в массиве, которые содержат значение, равное наибольшему.
# Программа должна вывести количество победителей соревнования.

# n, m = map(int, input().split())
# a = [max(list(map(int, input().split()))) for i in range(n)]
# print(a.count(max(a)))

5.6 / 13
# Симпатичный узор

# На днях Иван у себя в прихожей выложил кафель, состоящий из квадратных черных и белых плиток. Прихожая Ивана
# имеет квадратную форму 4х4, вмещающую 16 плиток. Теперь Иван переживает, что узор из плиток, который у него
# получился, может быть не симпатичным. С точки зрения дизайна симпатичным узором считается тот, который не содержит
# в себе квадрата 2х2, состоящего из плиток одного цвета.
# По заданному расположению плиток в прихожей Ивана требуется определить: является ли выполненный узор симпатичным.
# Программе поступает на вход 4 строки по 4 символа «W» или «B» в каждой, описывающие узор из плиток.
# Символ «W» обозначает плитку белого цвета, а «B» - черного.
# Ваша задача вывести «Yes», если узор является симпатичным и «No» в противном случае.

# a = [list(map(str, input())) for i in range(4)]
# flag = 'Yes'
# for i in range(3):
#     for j in range(3):
#         if a[i][j] == a[i + 1][j] == a[i][j + 1] == a[i + 1][j + 1]:
#             flag = 'No'
# print(flag)

5.6 / 14
# Миша и негатив

# Требуется написать программу, которая в качестве входных данных использует исходное бинарное черно-белое
# изображение и полученный Мишиной программой негатив, и на основе этого определяет количество пикселей,
# в которых допущена ошибка.
# Программа сперва считывает числа n и m (1 ≤ n, m ≤ 100) – высоту и ширину исходного изображения (в пикселях).
# Последующие n строк содержат описание исходного изображения. Каждая строка состоит из m символов «B» и «W».
# Символ «B» соответствует черному пикселю, а символ «W» – белому. Далее следует пустая строка, а после нее –
# описание выведенного Мишиной программой изображения в том же формате, что и исходное изображение.
# Необходимо вывести на экран число пикселей негатива, которые неправильно сформированы Мишиной программой.
# n, m = map(int, input().split())
# a = [list(map(str, input())) for i in range(n)]
# input()
# b = [list(map(str, input())) for j in range(n)]
# count = 0
# for i in range(n):
#     for j in range(m):
#         if a[i][j] == b[i][j]:
#             count += 1
# print(count)

5.6 / 15
# Таблица умножения

# Рассмотрим таблицу из n строк и n столбцов. Известно, что в клетке, образованной пересечением i-й строки и
# j-го столбца, записано число i×j. Строки и столбцы нумеруются с единицы.
# В единственной строке находятся числа n и x (1≤n≤10**5, 1≤x≤10**9) — размер таблицы и
# число, которое мы ищем в таблице.
# Выведите количество раз, которое число x встречается в таблице.

# n, m = map(int, input().split())
# count = 0
# for i in range(1, n + 1):
#     for j in range(1, n + 1):
#         if i * j == m:
#             count += 1
# print(count)


5.7 / 2
# Матчи

# Манао работает на спортивном телевидении. Он долгое время наблюдал за футбольными матчами чемпионата одной страны
# и начал замечать разные закономерности. Например, у каждой команды есть две формы: домашняя и выездная. Когда команда
# проводит матч на своем стадионе, футболисты надевают домашнюю форму, а когда на чужом — выездную. Единственное
# исключение из этого правила — когда цвет домашней формы принимающей команды совпадает с цветом формы гостей.
# В таком случае домашняя команда облачается в свою выездную форму. Цвета домашней и выездной формы для каждой
# команды различны.
# В чемпионате страны участвует n команд и он состоит из n·(n-1) матчей: каждая из команд принимает
# каждую другую команду на своем стадионе. Манао задумался, а сколько раз в течение одного чемпионата случится,
# что команда, играющая на своем стадионе, оденет выездную форму? Обратите внимание, что для подсчета этого
# количества порядок матчей не играет никакого значения.
# Вам даны цвета домашней и выездной формы каждой команды. Для удобства эти цвета пронумерованы целыми числами таким
# образом, что никакие два разных цвета не имеют одинаковый номер. Помогите Манао найти ответ на его вопрос.
# В первой строке содержится целое число n (2≤n≤30). В каждой из следующих n строк записана
# пара разделенных одним пробелом различных целых чисел hi, ai (1≤hi,ai≤100) — номер цвета домашней
# и выездной форм i-ой команды соответственно.
# В единственной строке выведите количество матчей, в которых домашняя команда выступит в выездной форме.

# b = [list(map(int, input().split())) for i in range(int(input()))]
# count = 0
# for i in range(len(b)):
#     for j in range(len(b)):
#         if b[i][0] == b[j][1]:
#             count += 1
# print(count)

5.7 / 3
# Морской бой - 2

# Емельян уже расставил все свои корабли, кроме одного однопалубного. Такой корабль занимает ровно одну клетку.
# Задана расстановка кораблей Емельяна. Найдите число способов поставить оставшийся однопалубный корабль.
# При этом учитывайте, что по правилам его можно ставить только в ту клетку, все соседние с которой не заняты.
# В этой задаче соседними считаются клетки, имеющие общую сторону.
# Необходимо вывести на экран ответ на задачу

# n, m = map(int, input().split())
# count, z = 0, []
# z.append('.' * (m + 2))
# for i in range(n):
#     a = '.' + input() + '.'
#     z.append(a)
# z.append('.' * (m + 2))
# for i in range(1, n + 1):
#     for j in range(1, m + 1):
#         if z[i][j] == z[i + 1][j] == z[i - 1][j] == z[i][j + 1] == z[i][j - 1] == '.':
#             count += 1
# print(count)
##############################################
# n, m = map(int, input().split())
# counter = 0
# z = [['.'] * (m + 2)]
# field = z + [['.'] + list(input()) + ['.'] for _ in range(n)] + z
# for i in range(1, n + 1):
#     for j in range(1, m + 1):
#         if field[i][j] == field[i-1][j] == field[i+1][j] == field[i][j-1] == field[i][j+1]  == '.':
#             counter += 1
# print(counter)

5.7 / 4
# Заполнение змейкой

# Даны числа n и m. Создайте массив A[n][m] и заполните его змейкой.
# Программа должна вывести полученный массив, при этом между числами может быть любое количество пробелов.

# n, m = map(int, input().split())
# k = 0
# for i in range(n):
#     tmp = []
#     for j in range(m):
#         tmp.append(k)
#         k += 1
#     if i % 2:
#         tmp.reverse()
#         print(*tmp)
#     else:
#         print(*tmp)

5.7 / 5
# Фотографии Брейна

# Фотография представляет собой матрицу размера n×m, в каждой ячейке которой хранится символ, обозначающий цвет
# соответствующего пикселя. Всего существует 6 цветов:
# 'C' (cyan) — голубой
# 'M' (magenta) — пурпурный
# 'Y' (yellow) — желтый
# 'W' (white) — белый
# 'G' (grey) — серый
# 'B' (black) — черный
# Фотографию можно считать черно-белой, если в ней есть только белый, серый или черный цвет.
# Если же присутствует хоть один пиксель голубого, пурпурного или желтого цвета, она цветная.
# В первой строке содержится два целых числа n и m — количество строк и столбцов в матрице пикселей фотографии.
# Далее следуют n строк, описывающих строки матрицы. Каждая из них состоит из m разделенных пробелом символов,
# описывающих цвета пикселей в строке.
# Каждый из символов в строке является одним из символов 'C', 'M', 'Y', 'W', 'G' или 'B'.
# В единственной строчке выведите «#Black&White», если фотография черно-белая, и «#Color», если цветная.

# n, m = map(int, input().split())
# bw_c = 0
# b = ' '.join([input() for i in range(n)]).split()
# for i in b:
#     if i in 'CMY':
#         bw_c += 1
# print('#Color' if bw_c != 0 else '#Black&White')

5.7 / 6
# Спираль

# Требуется вывести квадрат, состоящий из N×N клеток, заполненных числами от 1 до N2 по спирали (см. примеры).
# Программа получает на вход одно число n.
# Программа должна вывести матрицу, заполненную числами от 1 до N2 по спирали

# n, i, j = int(input()), 0, 0
# zeros = [[0] * n for _ in range(n)]
# for h in range(1, n * n + 1):
#     zeros[i][j] = h
#     if h == n * n:
#         break
#     if i <= j + 1 and i + j < n - 1:
#         j += 1
#     elif i < j and i + j >= n - 1:
#         i += 1
#     elif i >= j and i + j > n - 1:
#         j -= 1
#     elif i > j + 1 and i + j <= n - 1:
#         i -= 1
# for i in range(n):
#     print(*zeros[i])

5.7 / 7
# Тортминатор

# Дан прямоугольный торт, который имеет вид таблицы размером r×c. Каждая ячейка таблицы содержит либо гадкую клубничку,
# либо является пустой
# Тортминатор намерен съесть этот торт! Каждый раз, когда он ест, он выбирает строку или столбец, не содержащие гадкой
# клубнички, а содержащие по крайней мере одну несъеденную ячейку торта. Затем Тортминатор поедает все выбранные им
# ячейки торта. Тортминатор может есть сколько угодно раз.
# символ '.' обозначает ячейку торта без гадкой клубнички;
# символ 'S' обозначает ячейку торта с гадкой клубничкой.
# Пожалуйста, выведите максимальное количество ячеек, которые может съесть Тортминатор.

# n, m = map(int, input().split())
# a = [list(map(str, input())) for i in range(n)]
# b = list(map(list, zip(*a[::-1])))
# i_plus, j_plus = 0, 0
# for i in a:
#     if 'S' not in i:
#         i_plus += 1
#     else:
#         continue
# for j in b:
#     if 'S' not in j:
#         j_plus += 1
#     else:
#         continue
# print(i_plus * m + j_plus * n - i_plus * j_plus)
##############################################
# n, m = map(int, input().split())
# data = [input() for _ in range(n)]
# row = n - sum("S" in i for i in data)
# print(row)
# col = m - sum(any(data[i][j] == "S" for i in range(n)) for j in range(m))
# print(row * m + col * n - row * col)
##############################################
# n, m = map(int, input().split())
# a = [list(map(str, input())) for i in range(n)]
# b = list(map(list, zip(*a[::-1])))
# i_plus = sum('S' not in i for i in a)
# j_plus = sum('S' not in j for j in b)
# print(i_plus * m + j_plus * n - i_plus * j_plus)


5.8 / 1
# Треугольник Паскаля
# a = [[1] * i for i in range(1, int(input()) + 1)]
# print(a)
# for i in range(2, len(a)):
#     for j in range(1, i):
#         a[i][j] = a[i - 1][j] + a[i - 1][j - 1]
# for i in a:
#     print(*i)


5.9 / 6
# Программа принимает на вход два целых числа a и b.
# Если a<=b необходимо сформировать список квадратов целых чисел на интервале от а до b включительно.
# Если же a>b, необходимо сформировать список кубов целых чисел на интервале от a до b включительно,
# двигаясь в порядке убывания, и затем вывести его.

# a, b = map(int, input().split())
# print([i ** 2 if a <= b else i ** 3 for i in (range(a, b + 1) if a <= b else range(a, b - 1, -1))])

5.9 / 7
# st = 'Create a list of the first letters of every word in this string'
# print([i[0] for i in st.split()])

5.9 / 8
# При помощи list comprehension создайте список, состоящий из первых n заглавных букв английского алфавита
# ['A', 'B', 'C', 'D', ...]. Получить все заглавные буквы английского алфавита можно следующим образом:
# from string import ascii_uppercase
# print(ascii_uppercase) # выведет строку ABCDEFGHIJKLMNOPQRSTUVWXYZ
# На вход программе подается натуральное число n, n≤26.
# Программа должна вывести список из первых n заглавных букв английского алфавита

# print([chr(i + 65) for i in range(int(input()))])

5.9 / 9
# Программа должна вывести список из первых n заглавных букв английского алфавита, причем каждая буква должна
# быть продублирована в зависимости от своего порядкового номера
# ['A', 'BB', 'CCC', 'DDDD', 'EEEEE', 'FFFFFF', ...]

# print([chr(i + 64) * i for i in range(1, int(input()) + 1)])

5.9 / 9
# При помощи генератора-списков создайте список, состоящий из слов, начинающихся с буквы 't' или 'T'. Слова возьмите
# из переменной phrase, также не забывайте про метод split()
# В качестве ответа выведите полученный список, слова в нем должны стоять в том же порядке,
# в котором они стояли в изначальной фразе

# phrase = 'Take only the words that start with t in this sentence'
# print([i for i in phrase.split() if i[0] in 'Tt'])


5.10 / 2
# В вашем распоряжении есть двумерный список vector. Ваша задача при помощи генератора-списка сделать на основании
# vector линейный(одномерный) список и вывести его

# vector = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]
# b = [vector[i][j] for i in range(len(vector)) for j in range(3)]
# b = [j for i in vector for j in i]
# print(b)


6.1 / 2
# На вход программе поступает целое число n. Вам необходимо создать словарь, который будет включать в себя ключи
# от 1 до n, а значениями соответствующего ключа будет значение ключа в квадрате.
# В качестве ответа выведите полученный словарь

# d = {}
# for i in range(1, int(input()) + 1):
#     d.setdefault(i, i * i)
# print(d)
# print({i: i * i for i in range(1, int(input()) + 1)})

6.1 / 3
# Напишите программу, которая печатает словарь alphabet, где ключи - строчные английские символы, а значения -
# порядковые номера букв в алфавите.
# Начало вашего словаря должны быть таким {"a": 1, "b": 2 }
# В качестве ответа распечатайте ключи и значения данного словаря по алфавиту, каждую пару на новой строчке.
# Весь английский алфавит можно взять в переменной ascii_lowercase из модуля string:
# from string import ascii_lowercase
# print(ascii_lowercase)

# alphabet = {chr(i + 96): i for i in range(1, 27)}
# [print(k, v) for k, v in alphabet.items()]

6.1 / 4
# Есть два словаря, нужно их объединить в новый словарь rez и вывести его на экран
# rez = {'a': 100, 'b': 200, 'c': 333}
# d2 = {'x': 300, 'y': 200, 'z': 777}
# rez.update(d2)
# print(rez)
# print({'a': 100, 'b': 200, 'c': 333} | {'x': 300, 'y': 200, 'z': 777})

6.1 / 5
# Система регистрации

# Система должна работать по следующему принципу. Каждый раз, когда новый пользователь хочет зарегистрироваться, он
# посылает системе запрос name со своим именем. Если данное имя не содержится в базе данных системы, то оно заносится
# туда и пользователю возвращается ответ OK, подтверждающий успешную регистрацию. Если же на сайте уже присутствует
# пользователь с именем name, то система формирует новое имя и выдает его пользователю в качестве подсказки,
# при этом подсказка также добавляется в базу данных. Новое имя формируется по следующему правилу.
# К name последовательно приписываются числа, начиная с единицы (name1, name2, ...), и среди них находят такое
# наименьшее i, что name i не содержится в базе данных сайта.
# В первой строке входных данных задано число n. Следующие n строк содержат запросы к системе. Каждый запрос
# представляет собой непустую строку длиной не более 32 символов, состоящую только из строчных букв латинского алфавита.
# В выходных данных должно содержаться n строк — ответы системы на запросы: OK в случае успешной регистрации, или
# подсказку с новым именем, если запрашиваемое уже занято.

# z, d = [input() for i in range(int(input()))], {}
# for i in z:
#     if i not in d:
#         print('OK')
#         d[i] = 1
#     else:
#         print(i + str(d[i]))
#         d[i] += 1

6.1 / 6
# Переменные countries соединяют ряд стран с тремя крупнейшими городами каждой страны.
# Программе на вход будет поступать название города в переменную city. И ваша задача найти какой стране принадлежит
# введенный город. Если страна успешно найдена, необходимо вывести сообщение: INFO: <City> is a city in <Country>
# в противном случае # ERROR: Country for {City} not found
# Учитывайте, что регистр букв имеет значение

# countries = {
#     "Sweden": ["Stockholm", "Göteborg", "Malmö"],
#     "Norway": ["Oslo", "Bergen", "Trondheim"],
#     "England": ["London", "Birmingham", "Manchester"],
#     "Germany": ["Berlin", "Hamburg", "Munich"],
#     "France": ["Paris", "Marseille", "Toulouse"]
# }
#
# city = input()
# for Country, City in countries.items():
#     if city in City:
#         print(f'INFO: {city} is a city in {Country}')
#         break
# else:
#     print(f'ERROR: Country for {city} not found')


6.2 / 2
# Мы уже с вами подсчитывали сколько раз встречается число в списке при помощи метода подсчета. Там мы использовали
# список для хранения найденного количества
# Теперь ваша задача научиться использовать словарь для подсчета количества. Вашей программе поступает на вход строка,
# вам необходимо подсчитать сколько раз встретилась каждая буква в этой строке без учета регистра, при этом цифры и
# символы пунктуации нужно пропустить. Ответ нужно сохранить в словаре, в котором ключ - буква, а значение -
# количество раз, сколько эта буква встретилась в строке. В качестве ответа нужно вывести словарь

# d = {}
# for i in input().lower():
#     if i.isalpha():
#         d[i] = d.get(i, 0) + 1
# print(d)

6.2 / 3
# В этой задаче вам предстоит достать определенные данные из словаря data. Он уже будет определен и заполнен данными,
# поэтому никакого ввода значений в это программе делать не нужно, просто обращаетесь к переменной data
# Ваша задача получить значения ключа first_name у всех элементов и вывести их в алфавитном порядке,
# каждое имя с новой строки

# data = {'my_friends': {'count': 10, 'items': [
#     {'first_name': 'Kurt', 'id': 621547005, 'last_name': 'Cobain', 'bdate': '31.8.2005'},
#     {'first_name': 'Виолетта', 'id': 484200150, 'last_name': 'Кастилио'},
#     {'first_name': 'Иринка', 'id': 21886133, 'last_name': 'Бушуева', 'bdate': '28.8.1942'},
#     {'first_name': 'Данил', 'id': 282456573, 'last_name': 'Греков', 'bdate': '4.7.2002'},
#     {'first_name': 'Валентин', 'id': 184902932, 'last_name': 'Долматов', 'bdate': '25.5'},
#     {'first_name': 'Евгений', 'id': 620469646, 'last_name': 'Шапорин', 'bdate': '6.12.1982'},
#     {'first_name': 'Ангелина', 'id': 622328862, 'last_name': 'Краснова', 'bdate': '4.11.1995'},
#     {'first_name': 'Иван', 'id': 576015198, 'last_name': 'Вирин', 'bdate': '2.2.1915'},
#     {'first_name': 'Паша', 'id': 386922406, 'last_name': 'Воронов', 'bdate': '27.9'},
#     {'first_name': 'Ольга', 'id': 622170942, 'last_name': 'Савченкова', 'bdate': '20.12'}]}}
# b = []
# for first_name in data['my_friends']['items']:
#     b.append(first_name['first_name'])
# b.sort()
# print(*b, sep='\n')

# print(*sorted([i['first_name'] for i in data['my_friends']['items']]), sep='\n')

6.2 / 4
# Cтрока S1 называется анаграммой строки S2, если она получается из S2 перестановкой символов.
# Программа получает на вход две строки S1 и S2. Если строка S1 является анаграммой строки S2 нужно вывести
# YES, в противном случае - NO

# print('YES' if sorted(input()) == sorted(input()) else 'NO')
# s1, s2 = input(), input()
# d1 = {i: s1.count(i) for i in s1}
# d2 = {i: s2.count(i) for i in s2}
# print('YES' if d1 == d2 else 'NO')

6.2 / 5
# Азбука Морзе

# Вам дан английский текст. Закодируйте его с помощью азбуки Морзе.Каждая буква заменяется на последовательность точек
# и тире. В качестве тире используйте обычный дефис: «-», а в качестве точки — точку «.». Например, буква «g»
# превратится в трёхсимвольную строку «--.». Ниже в переменной morze для вашего удобства хранится словарь
# соответствия английских букв коду Морзе.
# Выведите каждое слово исходного текста, закодированное азбукой Морзе, на отдельной строке. Количество строк в ответе
# должно совпадать с количеством слов в исходном тексте. Между закодированными буквами нужно ставится ровно один пробел.
# Например, слово «Help» превратится в «.... . .-.. .--.». Строчные и заглавные буквы кодируются одинаково.

# morze = {'a': '•—', 'b': '—•••', 'c': '—•—•', 'd': '—••',
#          'e': '•', 'f': '••—•', 'g': '——•', 'h': '••••',
#          'i': '••', 'j': '•———', 'k': '—•—', 'l': '•—••',
#          'm': '——', 'n': '—•', 'o': '———', 'p': '•——•',
#          'q': '——•—', 'r': '•—•', 's': '•••', 't': '—',
#          'u': '••—', 'v': '•••—', 'w': '•——', 'x': '—••—',
#          'y': '—•——', 'z': '——••'}
# txt = input().lower()
# for i in txt:
#     for j in i:
#         if j not in morze:
#             print()
#         else:
#             j = morze[i]
#             print(j, end=' ')
# for i in input().lower().split():
#     print(*[morze[j] for j in i])

6.2 / 6
# На основании переменной persons, в которой хранится список кортежей, в каждом кортеже хранится имя, зп, пол и паспорт.
# Ваша задача создать словарь, где ключами будут имена, а значениями словарь из трех ключей: salary, gender и passport
# К примеру, если у вас есть изначально следующий список
# [
#     ('Bob Moore', 330000, 'M', '1635777202'),
# ]
# то из него должен получится следующий словарь
# {
#     'Bob Moore': {
#         'salary': 330000,
#         'gender': 'M',
#         'passport': '1635777202'
# }
# Сохраните результирующий словарь в переменную data.

# persons = [
#     ('Allison Hill', 334053, 'M', '1635644202'),
#     ('Megan Mcclain', 191161, 'F', '2101101595')]
# data = {}
# for i in persons:
#     data[i[0]] = dict(zip(['salary', 'gender', 'passport'], list(i)[1:]))
# print(data)

6.3 / 2
# В вашем распоряжении имеется вложенный список people, в котором хранятся имена и телефоны. Ваша задача создать
# словарь при помощи генератора словарей, в котором в качестве ключей будут хранится номера телефонов, а значениями
# будут имена владельцев. Обязательно сохраните этот словарь в переменной phone_book.
# Выводить ничего не нужно, только правильно заполните словарь в переменной phone_book
# people = [
#     ['Amy Smith', '694.322.8133x22426'],
#     ['Brian Shaw', '593.662.5217x338'],
#     ['Christian Sharp', '118.197.8810'],
#     ['Sean Schmidt', '9722527521'],
#     ['Thomas Long', '163.814.9938'],
#     ['Joshua Willis', '+1-978-530-6971x601'],
#     ['Ann Hoffman', '434.104.4302'],
#     ['John Leonard', '(956)182-8435'],
#     ['Daniel Ross', '870-365-8303x416'],
#     ['Jacqueline Moon', '+1-757-865-4488x652'],
#     ['Gregory Baker', '705-576-1122'],
#     ['Michael Spencer', '(922)816-0599x7007'],
#     ['Austin Vazquez', '399-813-8599'],
#     ['Chad Delgado', '979.908.8506x886'],
#     ['Jonathan Gilbert', '9577853541']
# ]
# phone_book = {i[1]: i[0] for i in people}
# print(phone_book)


6.4 / 4
# Допишите программу ниже, чтобы она вывела среднего арифметического всех нечетных элементов кортежа my_tuple.

# my_tuple = (
# -214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593,
# 905, -354, -377, -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829,
# -275, 619, -628, -241, -565, -835, -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543,
# 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370,
# 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)
# z = [i for i in my_tuple if i % 2]
# print(sum(z) / len(z))

6.4 / 5
# Сформировать кортеж, содержащий натуральные числа в интервале [a; b] и вывести его на экран.
# print(tuple(i for i in range(int(input()), int(input()) + 1)))
# print(tuple(range(int(input()), int(input()) + 1)))

6.4 / 6
# Сформировать кортеж, содержащий нечетные натуральные числа в интервале [ nn; n^2n2] и вывести его на экран.
# n = int(input())
# print(tuple(i for i in range(n, n * n + 1) if i % 2))


6.5 / 2
# Даны два списка чисел.
# Выведите все числа, которые входят как в первый, так и во второй список в порядке возрастания.

# print(*sorted(list(map(int, (set(input().split()) & set(input().split()))))))

6.5 / 3
# Даны два списка чисел. Выведите все числа в порядке возрастания, которые входят в первый список,
# но при этом отсутствуют во втором.

# print(*sorted(set(map(int, (set(input().split()) - set(input().split()))))))

6.5 / 4
# Напишите программу, которая выводит все цифры, встречающиеся в символьной строке больше одного раза.
# Программа должна вывести в одну строчку в порядке возрастания все цифры, встречающиеся во входной строке больше одного
# раза. Если таких цифр нет, нужно вывести слово 'NO'.

# s = [int(i) for i in input() if i.isdigit()]
# for i in set(s):
#     if i in s:
#         s.remove(i)
# print(*sorted(set(s)) if len(s) != 0 else ['NO'])

6.5 / 5
# Напишите программу, которая удаляет из строки все повторяющиеся символы, при этом регистр букв необходимо учитывать.
# Программа получает на вход строку, состоящую из заглавных и строчных символов, цифр и знаков препинания.
# Программа должна вывести исходную строку, из которой удалены все повторяющиеся символы.

# txt, s = input(), []
# for i in txt:
#     if i not in s:
#         s.append(i)
# print(*s, sep='')

6.5 / 6
# Дили Вили Били завели себе аккаунты в одной известной соцсети. Их страницы стали пользоваться популярностью и, конечно
# же, появились поклонники, оставляющие комментарии.  Ребята решили узнать у кого из них самое большое количество
# уникальных комментаторов. Ваша задача помочь им в этом и собрать нужную информацию.
# В каждой строке будет вводиться одно из имен наших героев, а затем через двоеточие и пробел имя комментатора.
# Комментаторы могут повторяться и комментировать разных персонажей
# Строка "конец" означает окончание ввода и встречается последней
# Ваша задача вывести в порядке уменьшения популярности 3 строки вида:
# "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>"
# На склонение давайте не будем обращать обращать внимания в этой задаче.
# Гарантируется, что количество уникальных комментаторов у всех наших героев разное. Могут быть ситуации, когда у героя
# нету ни единого комментатора, в таком случае все равно нужно выводить информацию о нем.

# D = {'Дили': set(), 'Били': set(), 'Вили': set()}
# txt = input()
# while txt != 'конец':
#     name, text = txt.split(':')
#     txt = input()
#     D[name].add(text)
# for n, t in sorted(D.items(), key=lambda item: - len(item[1])):
#     print(f'Количество уникальных комментаторов у {n} - {len(t)}')

6.5 / 7
# Девушка или Юноша

# В наши дни очень много парней ставят себе фотографии красивых девушек на аватарки на форумах. Из-за этого очень часто
# сложно определить пол пользователя на форуме. В прошлом году наш герой пообщался в чате на форуме с одной красоткой
# Вчера наш герой захотел увидеть свою красотку в реальной жизни и, каково же было его удивление, когда красоткой
# оказался здоровенный мужчина! Наш герой очень расстроился и теперь он, наверное, никогда больше не сможет полюбить.
# Сейчас к нему пришла в голову идея, как по имени пользователя определить его пол.
# Вот его метод: если количество различных символов в имени пользователя нечетное, тогда пользователь мужского пола,
# иначе — женского. Вам дана строка, обозначающая имя пользователя, помогите нашему герою определить по ней пол
# пользователя по описанному методу.
# Если пользователь оказался женского пола по методу нашего героя, выведите «CHAT WITH HER!» (без кавычек), иначе,
# выведите «IGNORE HIM!» (без кавычек).

# print('CHAT WITH HER!' if not len(set(input())) % 2 else 'IGNORE HIM!')
# print(['CHAT WITH HER!','IGNORE HIM!'][len(set(input()))%2])

6.5 / 8
# Не смешите мои подковы

# Конь Валера собрался с друзьями на вечеринку. Он давно следит за тенденциями моды и поэтому знает, что сейчас очень
# популярно носить все подковы разного цвета. С прошлого года у Валеры остались четыре подковы, но, возможно, некоторые
# из них имеют одинаковый цвет. В этом случае, чтобы не ударить в грязь лицом перед своими стильными товарищами,
# ему нужно сходить в магазин и купить дополнительно несколько каких-нибудь подков.
# К счастью в магазине продаются подковы всех возможных цветов, и у Валеры имеется достаточно денег, чтобы купить любые
# четыре. Однако в целях экономии он хотел бы потратить как можно меньше денег, поэтому вам нужно помочь Валере и
# определить, какое минимальное количество подков нужно купить, чтобы он смог надеть на вечеринку четыре подковы
# различного цвета.
# В первой строке через пробел записаны четыре целых числа — цвета подков, имеющихся у Валеры.
# Выведите единственное целое число — минимальное количество подков, которое нужно купить.

# print(4 - len(set(input().split())))

6.5 / 9
# Красивый год

# Кажется, еще совсем недавно наступил новый 2013 год. А знали ли Вы забавный факт о том, что 2013 год является первым
# годом после далекого 1987 года, в котором все цифры различны?
# Теперь же Вам предлагается решить следующую задачу: задан номер года, найдите наименьший номер года, который строго
# больше заданного и в котором все цифры различны.
# Выведите единственное целое число — минимальный номер года, который строго больше y, в котором все цифры различны.
# Гарантируется, что ответ существует.

# a = int(input()) + 1
# while len(set(str(a))) != 4:
#     a += 1
# print(a)

6.5 / 10
# Антон и буквы

# Недавно у Антона появилось множество, состоящие из маленьких латинских букв. Он аккуратно выписал все буквы, которые
# в него входят в одну строку через запятую. Для красоты он так же добавил в начало этой строки открывающуюся фигурную
# скобку, а в конец — закрывающуюся.
# К сожалению, Антон иногда забывал, что уже записал некоторую букву, и выписывал ее снова. Он просит вас посчитать
# общее число различных букв в его множестве.
# В первой и единственной строке задано описание множества букв. Длина строки не превышает 1000. Гарантируется, что
# строка начинается с открывающейся фигурной скобки, а заканчивается закрывающейся. Между ними через запятую
# перечислены маленькие латинские буквы. После каждой запятой следует пробел.
# Выведите единственное число — количество различных букв в множестве Антона.

# print(len(set(i for i in input() if i.isalpha())))
# print(len(set(input()) - set('{ },')))

6.5 / 11
# Панграмма

# Слово или предложение на некотором языке называется панграммой, если в нем встречаются все символы алфавита этого
# языка хотя бы один раз. Панграммы часто используют в типографии для демонстрации шрифтов или тестирования средств
# вывода различных устройств.

# Вам дана строка, состоящая из маленьких и больших латинских букв. Проверьте, является ли эта строка панграммой.
# Считается, что строка содержит букву латинского алфавита, если эта буква встречается в верхнем или нижнем регистре.
# Выведите «YES», если строка является панграммой, и «NO» в противном случае.

# n, L = int(input()), set(input().lower())
# print('NO' if len(L) != 26 else 'YES')
# print(['NO', 'YES', input()][len(set(input().lower()))==26])


7.1 / 4
# Напишите функцию check_password, которая проверяет переданный ей пароль на сложность и печатает на экран
# результат проверки.
# Сложным паролем будет считаться комбинация символов, в которой:
# Есть хотя бы 3 цифры
# Есть хотя бы одна заглавная буква
# Есть хотя бы один символ из следующего набора "!@#$%*"
# Общая длина не менее 10 символов
# Если пароль прошел все проверки, функция должна вывести на экран фразу "Perfect password", в противном случае -
# "Easy peasy"

# def check_password(a):
#     num = [i for i in a if i.isdigit()]
#     tit = [i for i in a if i.isupper()]
#     sep = [i for i in '!@#$%*' if i in a]
#     if len(num) > 2 and len(tit) > 0 and len(sep) > 0 and len(a) > 9:
#         print("Perfect password")
#     else:
#         print("Easy peasy")
# a = input()
# check_password(a)

7.1 / 5
# Создайте функцию count_letters, которая принимает на вход фразу и подсчитывает, какое количество в ней строчных(K) и
# заглавных (N) букв, все остальные символы игнорируются. Функция должна вывести на экран информацию о найденных буквах
# в определенном формате.
# Количество заглавных символов: N
# Количество строчных символов: K
# Вам необходимо написать только определение функции.

# def count_letters(txt):
#     print(f'Количество заглавных символов: {len([i for i in txt if i.isupper()])}')
#     print(f'Количество строчных символов: {len([i for i in txt if i.islower()])}')
# txt = input()
# count_letters(txt)


7.2 / 1
# import turtle as t
# from random import *
# t.Screen().colormode(255)
# t.speed(0)
# t.bgcolor((0, 0, 0))
# for i in range(333):
#     t.color(randint(0, 255), randint(0, 255), randint(0, 255))
#     t.left(144)
#     t.forward(i)
# t.done()

7.2 / 2
# Напишите функцию repeat_please_n_times, которая принимает один аргумент n - натуральное число. Функция
# repeat_please_n_times должна n раз распечатать фразу "Just do it" в отдельной строчке
# Ваша задача написать только определение функции, вызывать ее не нужно

# def repeat_please_n_times(n):
# for i in range(n):
#     print('Just do it')
# print('Just do it\n' * n)
# n = int(input())
# repeat_please_n_times(n)

7.2 / 3
# Напишите функцию print_initials(name, surname, middlename), которая принимает три параметра:
# name – имя человека;
# surname – фамилия человека;
# middlename– отчество человека;
# а затем выводит на печать фамилию и инициалы в определенном формате (первая буква фамилии должна стать заглавной, все
# остальные строчные; в имени и отчестве остаются только по одной букве в верхнем регистре).
# Ваша задача написать только определение функции, вызывать ее не нужно

# def print_initials(name, surname, middlename):
#     print(f'{surname.title()} {name[0].title()}.{middlename[0].title()}.')
# name, surname, middlename = (input() for _ in range(3))
# print_initials(name, surname, middlename)


7.3 / 2
# Напишите функцию factorial, которая принимает на вход одно неотрицательное число, и возвращает значение
# факториала данного числа.
# Нужно определить только функцию

# def factorial(x):
#     fac = 1
#     for i in range(2, x + 1):
#         fac = fac * i
#     return fac
# print(factorial(int(input())))

7.3 / 3
# Снова НОД

# В этой задаче вам необходимо воспользоваться уже готовой функцией gcd(a, b), которая принимает два числа и находит
# наибольших общий делитель для них.
# Ваша задача при помощи функции gcd определить НОД произвольного количества чисел.
# На первой строке вводится количество чисел. Далее идут n строк, в каждой из которых натуральное число.

# def gcd(a, b):
#     while b > 0:
#         a, b = b, a % b
#     return a
# s = [int(input()) for i in range(int(input()))]
# print(gcd(min(s), max(s)))

7.3 / 4
# Ваша задача написать функция find_duplicate, которая принимает один аргумент - список чисел. Функция должна возвращать
# список из дублей, каждый дубль нужно брать только один раз в том порядке, в котором они встречаются в исходном списке.
# Под дублем будем подразумевать число, которое присутствовало в списке несколько раз.

# def find_duplicate(s):
#     z = []
#     for i in s:
#         if s.count(i) > 1 and i not in z:
#             z.append(i)
#     return z

7.3 / 5
# Напишите функцию first_unique_char, которая принимает строку символов и возвращает позицию первого уникального символа
# в строке. В случае, если уникальных символов в переданной строке нет, верните -1. Регистр символов не учитывайте.

# def first_unique_char(s):
#     z = []
#     for i in s:
#         if s.count(i) == 1 and i not in z:
#             z.append(i)
#     return s.index(z[0]) if len(z) != 0 else -1
##############################################
# def first_unique_char(s):
#     for i in s:
#         if s.count(i) == 1:
#             return s.index(i)
#     return -1
# s = input()
# print(first_unique_char(s))

7.3 / 6
# Ваша задача написать функцию format_namelist, которая принимает список словарей, у каждого словаря в
# списке есть только ключ name
# Функция format_namelist должна вернуть отформатированную строку, в которой все имена из списка разделяются
# запятой кроме последних двух имен, они должны быть разделены союзом "и". Если в списке нет ни одного имени,
# функция должна вернуть пустую строку. Ниже представлены примеры:
# format_namelist([ {'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'} ])
# # returns 'Bart, Lisa и Maggie'
# format_namelist([ {'name': 'Bart'}, {'name': 'Lisa'} ])
# # returns 'Bart и Lisa'
# format_namelist([ {'name': 'Bart'} ])
# # returns 'Bart'
# format_namelist([])
# returns ''

# def format_namelist(n):
#     z = [val for i in n for key, val in i.items()]
#     t = []
#     if len(z) == 1:
#         t = [z[-1]]
#     if len(z) > 1:
#         for name in range(len(z) - 2):
#             t.append(z[name] + ',')
#         t.append(z[-2] + ' и ' + z[-1])
#     return ' '.join(t)
##############################################
# def format_namelist(n):
#     z = [val for i in n for key, val in i.items()]
#     if len(z) > 1:
#         z.insert(len(z) - 1, 'и')
#     if len(z) > 3:
#         for name in range(len(z) - 3):
#             z[name] = z[name].ljust(len(z[name]) + 1, ',')
#     return ' '.join(z)
# n = [{'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'}, {'name': 'Homer'}, {'name': 'Marge'}]
# print(format_namelist(n))
##############################################
# def format_namelist(dy):
#     return ' и '.join(i['name'] for i in dy).replace(' и', ',', len(dy) - 2)

7.3 / 7
# Ваша задача написать функцию domain_name, которая принимает строку url, извлекает из нее доменное имя и
# возвращает его в качестве строки
# domain_name("http://google.com") # возвращает "google"
# domain_name("http://google.co.jp") # возвращает  "google"
# domain_name("www.xakep.ru") # возвращает "xakep"
# domain_name("https://youtube.com") # возвращает "youtube"
# domain_name("https://www.asos.com") # возвращает "asos"
# domain_name("http://www.lenovo.com") # возвращает "lenovo"
# URL может начинаться с протоколов http://  https:// или с www. URL, начинающиеся с протоколов
# http://  https://, могут также содержать www.

# def domain_name(url:str) -> str:
#     if 'https://' in url:
#         url = url.replace('https://', '')
#     elif 'http://' in url:
#         url = url.replace('http://', '')
#     if 'www.' in url:
#         url = url.replace('www.', '')
#     url = url.split('.')
#     return ''.join(url[0])
##############################################
# def domain_name(url:str) -> str:
#     url = url.replace("http://", "").replace("https://", "").replace("www.", "")
#     return url.split('.')[0]

7.3 / 8
# Сколько нулей на конце факториала N!

# В этой задаче вам необходимо воспользоваться уже готовой функцией factorial, которая принимает неотрицательное число,
# и возвращает значение факториала данного числа.
# Ваша задача создать функцию trailing_zeros, которая принимает неотрицательное число, находит его факториал и
# возвращает сколько нулей на конце этого факториала .
# trailing_zeros(6) # возвращает "1" потому что 6! = 1 * 2 * 3 * 4 * 5 * 6 = 720
# trailing_zeros(10) # возвращает 2 потому что 10! = 3 628 800
# trailing_zeros(20) # возвращает 4 потому что 20! = 2 432 902 008 176 640 000
# Нужно написать только определение функций trailing_zeros и factorial

# def factorial(n: int):
#     '''
#     Функция находит факториал данного числа
#     :param n: принимает неотрицательное число
#     :return: возвращает значение факториала
#     '''
#     fac = 1
#     for i in range(2, n + 1):
#         fac *= i
#     return fac
# def trailing_zeros(n: int) -> int:
#     fac, s = factorial(n), 0
#     while fac % 10 == 0:
#         s += 1
#         fac //= 10
#     return s
# print(factorial.__doc__)


7.6 / 3
# Напишите функцию, которая имя и возраст водителя. Функция должна распечатать на экран заключение, может ли данный
# водитель управлять транспортом и определять она должна это по возрасту водителя:
# он должен быть больше или равен MIN_DRIVING_AGE
# Если водитель может управлять, выведите фразу "<name> может водить> " ,
# в противном случае "<name> еще рано садиться за руль"

# def allowed_driving(name, age):
#     print(f'{name} еще рано садиться за руль' if age <MIN_DRIVING_AGE else f'{name} может водить')
# MIN_DRIVING_AGE = 18


7.8 / 4
# Напишите функцию count_args, которая принимает произвольное количество аргументов. Данная функция должна возвращать
# количество переданных ей на вход аргументов
# Вам необходимо написать только определение функции

# def count_args(*args):
#     return len(args)
# print(count_args(1,3,5,6,8,9,90,0))

7.8 / 5
# Давайте теперь создадим функцию print_goods, которая печатает список покупок. На вход она будет принимать
# произвольное количество значений, а товаром мы будем считать любые непустые строки. То есть числа, списки, словари и
# другие нестроковые объекты вам нужно будет проигнорировать. Функция print_goods должна печатать список товаров в виде:
# <Порядковый номер товара>. <Название товара> (см. пример ниже). В случае, если в переданных значениях не встретится
# ни одного товара, необходимо распечатать текст "Нет товаров"
#       print_goods('apple', 'banana', 'orange')
#       """ данный вызов печатает следующие строки
#       1. apple
#       2. banana
#       3. orange
#       """
#       print_goods(1, True, 'Грушечка', '', 'Pineapple')
#       """ Этот вызов распечатает следующее
#       1. Грушечка
#       2. Pineapple
#       """
#       print_goods([], {}, 1, 2)
#       """ Этот вызов распечатает следующее
#       Нет товаров
#       """
# Вам необходимо написать только определение функции

# def print_goods(*args):
#     z = [i for i in args if type(i) == str and len(i) > 0]
#     # 1 СПОСОБ
#     print('Нет товаров') if len(z) == 0 else [print(f'{z.index(i) + 1}. {i}') for i in z]
#     # 2 СПОСОБ
#     for i, v in enumerate(z, 1):
#         print(f'{i}. {v}')
#     if len(z) == 0:
#         print('Нет товаров')
# print_goods(1, True, 'Грушечка', '', 'Pineapple')
# print_goods([], {}, 1, 2)

7.8 / 6
# Напишите функцию info_kwargs, которая принимает произвольное количество именованных аргументов.
# Функция info_kwargs должна распечатать именованные аргументы в каждой новой строке в виде пары <Ключ> = <Значения>,
# причем ключи должны следовать в алфавитном порядке. Пример работы смотрите ниже
#       info_kwargs(first_name="John", last_name="Doe", age=33)
#       """ данный вызов печатает следующие строки
#       age = 33
#       first_name = John
#       last_name = Doe
#       """
# Вам необходимо написать только определение функции

# def info_kwargs(**kwargs):
#     # 1 СПОСОБ
#     for k, v in sorted(kwargs.items()):
#         print(f'{k} = {v}')
#     # 2 СПОСОБ
#     [print(f'{k} = {v}') for k, v in sorted(kwargs.items())]
# info_kwargs(first_name="John", last_name="Doe", age=33)


7.9 / 2
# Дано натуральное число N и последовательность из N элементов.
# Требуется вывести эту последовательность в обратном порядке.
# Программа принимает на вход натуральное число N (N ≤ 103). Во второй строке через пробел идут N целых чисел,
# по модулю не превосходящих 103 - элементы последовательности.
# Ваша задача вывести заданную последовательность в обратном порядке.

# n = input()
# print(*input().split()[::-1])
# a, b = int(input()), input().split()
# def rec(a):
#     if a > 0:
#         rec(a - 1)
#         print(b[-a], end=" ")
# rec(a)

7.9 / 3
# Последовательностью Фибоначчи называется последовательность чисел a0, a1, ..., an, ..., где
# a0 = 0, a1 = 1, ak = ak-1 + ak-2 (k > 1).
# Требуется найти N-е число Фибоначчи.
# Программе поступает на вход целое число N (0 ≤ N ≤ 30) - порядковый номер числа Фибоначчи.

# def fib(n):
#     if n == 1:
#         return 0
#     if n == 2:
#         return 1
#     return fib(n - 1) + fib(n - 2)
# print(fib(int(input()) + 1))

# def fib(n):
#     if n < 2:
#         return n
#     return fib(n - 1) + fib(n - 2)
# print(fib(int(input())))

# def fib(n):
#     if n in MEMO:
#         return MEMO[n]
#     MEMO[n] = fib(n - 1) + fib(n - 2)
#     return MEMO[n]
# n = int(input())
# MEMO = {0: 0, 1: 1}
# print(fib(n))

7.9 / 4
# Напишите функцию list_sum_recursive, которая принимает на вход список из целых чисел и возвращает сумму элементов
# переданного списка. Не забывайте, что реализовать это нужно при помощи рекурсии.
# Ваша задача только написать определение функции list_sum_recursive

# def list_sum_recursive(l):
#     if len(l) == 0:
#         return 0
#     return int(l[0]) + int(list_sum_recursive(l[1:]))
#     return s.pop() + list_sum_recursive(s) if s else 0
# l = input().split()
# print(list_sum_recursive(l))

7.9 / 5
# Представьте, что у нас есть список целых чисел неограниченной вложенности. То есть наш список может состоять
# из списков, внутри которых также могут быть списки. Ваша задача превратить все это в линейный список при помощи
# функции flatten
# flatten([1, [2, 3, [4]], 5]) # вернет [1,2,3,4,5]
# flatten([1, [2,3], [[2], 5], 6]) # вернет [1,2,3,2,5,6]
# flatten([[[[9]]], [1,2], [[8]]]) # вернет [9,1,2,8]

# def flatten(s, z=None):
#     if z is None:
#         z = []
#     for i in s:
#         if type(i) == list:
#             flatten(i, z)
#         else:
#             z.append(i)
#     return z
# print(flatten([1, [2, 3, [4]], 5]))
# print(flatten([1, [2, 3], [[2], 5], 6]))


7.10 / 1.1
# Вставить звёздочки

# Дана строка, содержащая только английские буквы (большие и маленькие). Добавить символ ‘*’ (звездочка) между буквами
# (перед первой буквой и после последней символ ‘*’ добавлять не нужно).
# Вывести строку, которая получится после добавления символов '*'.

# def stars(z):
#     if len(z) == 1:
#         return z
#     return z[0] + '*' + stars(z[1:])
# z = 'LItBeoFLcSGBOFQxMHoIuDDWcqcVgkcRoAeocXO'
# print(stars(z))

7.10 / 1.2
# Сформировать новую строку со скобками

# Дана строка, содержащая только английские буквы (большие и маленькие) и открывающиеся скобки. Сформировать новую
# строку добавлением справа «зеркальной» строки с закрывающимися скобками. "(abc(def(g" -> "(abc(def(gg)fed)cba)"
# Вывести строку, которая получится после "зеркальной" половины строки.

# def rec(s):
#     if len(s) == 0:
#         return s
#     if s[0] == '(':
#         return s[0] + rec(s[1:]) + ')'
#     return s[0] + rec(s[1:]) + s[0]
# s = '(abc(def(g'
# print(rec(s))

7.10 / 1.3
# Нумеролог

# Чтобы предсказать судьбу человека, нумеролог берет время жизни человека в секундах, затем складывает все цифры этого
# числа. Если полученное число состоит более чем из одной цифры, операция повторяется, пока в числе не останется одна
# цифра. Затем по полученной цифре и числу операций, необходимых для преобразования числа в цифру нумеролог
# предсказывает судьбу человека. Нумеролог плохо умеет считать, а числа, с которыми он работает, могут быть очень
# большими. Напишите программу, которая бы делала все расчеты за него.
# Входной файл INPUT.TXT содержит число N – время жизни человека в секундах (1 ≤ N ≤ 101000).
# В выходной файл OUTPUT.TXT выведите два числа через пробел: полученную цифру из числа N и число преобразований.

# def number(n, counter=0):
#     if n < 10:
#         return f'{n} {counter}'
#     summ = 0
#     for i in str(n):
#         summ += int(i)
#     counter += 1
#     return number(summ, counter)
# n = int(input())
# print(number(n))

7.10 / 2
# Сортировка слиянием (merge sort)

# Есть несколько типов сортировки, которые используют рекурсию.
# Создать функцию merge_sort, которая будет принимать исходный список и возвращать новый отсортированный в
# порядке неубывания список.
# Также для реализации функции merge_sort вам понадобится реализовать функцию merge_two_list.
# Функция merge_two_list должна принимать два отсортированных по неубыванию списка, сливать их в один большой список
# также отсортированный по неубыванию (задача Слияние списков) и возвращать его.
# Задача написать только определение функций merge_sort и merge_two_list, при этом нельзя пользоваться
# встроенными сортировками в Python

# def merge_two_list(a, b):
#     i, j, rez = 0, 0, []
#     while i < len(a) and j < len(b):
#         if a[i] < b[j]:
#             rez.append(a[i])
#             i += 1
#         else:
#             rez.append(b[j])
#             j += 1
#     rez += a[i:] + b[j:]
#     return rez
#
#
# def merge_sort(s):
#     if len(s) == 1:
#         return s
#     return merge_two_list(merge_sort(s[:len(s) // 2]), merge_sort(s[len(s) // 2:]))
#
#
# len_lst = int(input())
# lst = list(map(int, input().split()))
# print(*merge_sort(lst))

7.10 / 3
# Быстрая сортировка (quick sort) | Разбор

# Нужно создать функцию quick_sort, которая будет принимать исходный список и возвращать новый отсортированный
# в порядке неубывания список. Необходимо написать только определение функций quick_sort, при этом нельзя пользоваться
# встроенными сортировками в Python

# from random import choice
#
#
# def quick_sort(s):
#     if len(s) > 1:
#         x = choice(s)
#         left = [i for i in s if i < x]
#         mid = [i for i in s if i == x]
#         right = [i for i in s if i > x]
#
#         return quick_sort(left) + mid + quick_sort(right)
#     else:
#         return s
#
#
# len_lst = int(input())
# lst = list(map(int, input().split()))
# print(*quick_sort(lst))


7.11
# РЕКУРСИВНЫЙ ОБХОД ФАЙЛОВ
# import os
# path = 'D:\\Медиа'
# def obxodFile(path, lvl=1):
#     print('УРОВЕНЬ>>>', lvl, 'СОДЕРЖИМОЕ:', os.listdir(path))
#     for i in os.listdir(path):
#         if os.path.isdir(path + '\\' + i):
#             print('Спуск', path + '\\' + i)
#             obxodFile(path + '\\' + i, lvl + 1)
#             print('Возвращаемся в', path)
# obxodFile(path)


# ДОМАШНЯЯ РАБОТА. ПОИСК ФАЙЛА ПО ИМЕНИ
# import os
# def FileSearch(path, name):
#     for i in os.listdir(path):
#         path_wave = path + '\\' + i
#         if i == name:
#             print(f'ПУТЬ К ФАЙЛУ {name} >>> {path_wave}')
#         if os.path.isdir(path_wave):
#             FileSearch(path_wave, name)
# name, path = input(), 'D:\\Медиа'
# FileSearch(path, name)

7.12
# Анонимная функция Lambda

# def kvadrat(a, b, c):
#     return lambda x: a * x ** 2 + b * x + c
# val1 = kvadrat(5, 2, 6)
# print(val1(2))

7.12 / 2
# Анонимная функция Lambda
# Напишите lambda функцию, которая принимает одно число и увеличивает его на 10.
# Для проверки решения присвойте вашу lambda функцию переменной adding_10

# adding_10 = lambda x: x + 10
# print(adding_10(7))

7.12 / 3
# Напишите lambda функцию, которая принимает строку и отвечает на вопрос, начинается ли переданная строка с буквы W
# Для проверки решения присвойте вашу lambda функцию переменной starts_with

# starts_with = lambda x: x[0] == 'W'
# starts_with = lambda x: x.startswith('W')
# print(starts_with("efef"))


7.14 / 1
# Замыкания в Python. Closure Python
# Задача: вывести список возведённой в степени (a ... b) последовательности от a до b с увеличением степени
# (i^a, (i+1)^(a+1), ..., ((i+(b-a))^b)), используя замыкания
# 1 10 /// 1 4 27 256 3125 46656 823543 16777216 387420489 10000000000
# -2 6 /// 0.25 -1.0 1 1 4 27 256 3125 46656

# def rate(one, two):
#     z = [i ** i for i in range(one, two + 1)]
#     return z
# first, last = map(int, input().split())
# print(*rate(first, last))

#                                                   НЕ ПОНЯЛ!!!
# def rate(one):
#     count = 0
#     def inner():
#         nonlocal count
#         count += 1
#         return count
#     return inner
# first, last = map(int, input().split())
# foo = rate(first)
# print(*list(map(lambda x: x ** foo(), range(first, last + 1))))

7.14 / 2
# Создать функцию multiply, которая принимает один аргумент. Функция должна запомнить это значение, и вернуть результат
# умножения этого числа с переданным вновь значением (см. примеры)

# def multiply(x):
#     def inner(y):
#         return x * y
#     return inner
# f_2 = multiply(2)
# print("Умножение 2 на 5 =", f_2(5))  # 10
# print("Умножение 2 на 15 =", f_2(15))  # 30
# f_3 = multiply(3)
# print("Умножение 3 на 5 =", f_3(5))  # 15
# print("Умножение 3 на 15 =", f_3(15))  # 45


7.15
# Замыкания в Python Часть 2
# from time import perf_counter
# def timer():
#     start = perf_counter()
#     def inner():
#         return perf_counter() - start
#     return inner
# t = timer()
# print(t())
# print(t())
##############################################
# def multi(x, y):
#     return x * y
# def counter(func):
#     count = 0
#     def inner(*args, **kwargs):
#         nonlocal count
#         count += 1
#         print(f'Функция {func.__name__} вызывалась {count} раз.')
#         return func(*args, **kwargs)
#     return inner
# d = counter(multi)
# print(d(5, 7))
# print(d(6, 7))
##############################################
# ДОМАШНЯЯ РАБОТА. Найти разницу между 2мя соседними вызовами времени в таймере.
# from time import perf_counter
# def timer(first=perf_counter()):
#     def inner():
#         nonlocal first
#         second = perf_counter()
#         rez = second - first
#         first = second
#         return rez
#     return inner
# t = timer()
# print(t())
# print(t())
# print(t())


7.16 / 1
# Декораторы в Python Часть 1
# Декоратор это функция внутрь которой входит еще какая-либо функция выполнение которой дополняет функция декоратор,
# в декораторе также присутствует замыкание.
# Проще говоря декоратор это функция дополняющая функцию которая входит в декоратор.

# def decorator(func):  # Создаем функцию. Внутрь нее передаем аргумент func, Этот аргумент будет являться функцией.
#     def inner(*args, **kwargs):  # Создаем вложенную функцию
#         print('Привет')
#         print('Дорогой')
#         func(*args, **kwargs)  # Вызываем функцию которую мы передали в функции декоратор и передаем n кол-во арг-в.
#     return inner  # Возвращаем функцию чтобы получилось замыкание.
# def names(name):  # Создаем функцию names() которая принимает аргумент name. В name будем передавать имя.
#     print(name)  # Выводим имя
# # Теперь есть два варианта вывода имени, Первый:
# names = decorator(names) # В оператор names кладем f() decorator кот. принимает арг-т names который является f() names
# names(input())  # вызываем функцию names в которую передаем имя которое, запишем через консоль input’ом
# # Второй вариант, которым следует пользоваться:
# @decorator  # навешиваем функцию decorator через @
# def names(name):
#     print(name)  # Функция на которую навешиваем декоратор
# names(input())  # передаем имя через консоль.

7.16 / 2
# Напишите декоратор text_decor, который оборачивает вызов декорированной функции фразами «Hello» и «Goodbye!»:
# фраза «Hello» печатается до вызова, фраза «Goodbye!» - после

# def text_decor(func):
#     def inner(*args, **kwargs):
#         print('Hello')
#         func(*args, **kwargs)
#         print('Goodbye!')
#     return inner

# @text_decor
# def simple_func():
#     print('I just simple python func')
# simple_func()

# @text_decor
# def multiply(num1, num2):
#     print(num1 * num2)
# multiply(3, 5)

7.16 / 3
# Напишите декоратор repeater, который дважды вызывает декорированную функцию
# def repeater(func):
#     def inner(*args, **kwargs):
#         [func(*args, **kwargs) for i in range(2)]
#     return inner
#
# @repeater
# def multiply(num1, num2):
#     print(num1 * num2)
# multiply(2, 7)  # после это распечатается две строки со значением 14
# multiply(5, 3)  # после это распечатается две строки со значением 15

7.16 / 4
# Напишите декоратор double_it, который возвращает удвоенный результат вызова декорированной функции
# def double_it(func):
#     def inner(*args, **kwargs):
#         return 2 * func(*args, **kwargs)
#     return inner
#
# @double_it
# def multiply(num1, num2):
#     return num1 * num2
# res = multiply(9, 4)  # произведение 9*4=36, но декоратор double_it удваивает это значение
# print(res)
#
# @double_it
# def get_sum(*args):
#     return sum(args)
# res = get_sum(1, 2, 3, 4, 5)
# print(res)  # печатает 30


7.17
# Декораторы в Python Часть 2

# При использовании декораторов функция, которая декорируется, теряет свое имя и строки с описанием (документацию).
# Чтобы этого избежать можно выбрать два пути:
#   1) В функции-декораторе нужно добавить строки с пересохранением __name__ и __doc__ функции inner
#   (сохранить значения функции-аргумента).
#   2) Импортировать модуль wraps (from functool import wraps) и навесить декоратор @wraps на inner функцию.

# from functools import wraps
# def decorator(func):
#     @wraps(func)
#     def inner(*args, **kwargs):
#         print('^^')
#         func(*args, **kwargs)
#         print('__')
#     # inner.__name__ = func.__name__
#     # inner.__doc__ = func.__doc__
#     return inner
#
#
# @decorator
# def sqr(x):
#     '''
#     Функция sqr возвращает квадрат числа x
#     :param x:
#     :return: x ** 2
#     '''
#     print(x ** 2)
#
# sqr(5)
# print(sqr.__name__)
# print(sqr.__doc__)


9.1 / 2
# Чтение и запись данных. Функция open
# Напишите функцию file_read, которая принимает имя файла, и печатает его содержимое.
# Учитывайте, что содержимое файла может быть как на русском языке, так и на английском

# def file_read(file_name):
#     file = open(file_name, 'r', encoding='utf-8')
#     print(file.read())


# print(file.read(3))
# file.seek(0)
# print(file.readline())
# for row in file:
#     print(row)
#
# str1 = file.readlines()
# print(str1)
# file.write('hello\n')

9.1 / 3
# Напишите функцию create_file_with_numbers, которая принимает на вход одно целое положительное число - n.
# Функция должна создать файл с названием "range_<number>.txt" и наполнить его целыми числами от 1 до n включительно,
# причем каждое число записывается в отдельной строке
# Пример: функция create_file_with_numbers(5) должна создать файл "range_5.txt" с содержимым

# def create_file_with_numbers(n):
#     with open(f'range_{n}.txt', 'w', encoding='utf-8') as file:
#         for i in range(1, n + 1):
#             file.write(f'{str(i)}\n')
#         print(file.readline())
#
# # def create_file_with_numbers(n):
# #     open(f'range_{n}.txt', 'w').writelines('\n'.join(map(str, range(1, n + 1))))
#
# create_file_with_numbers(int(input()))

9.1 / 4
# Напишите функцию longest_word_in_file, которая принимает имя файла и внутри его содержимого находит самое длинное
# слово и возвращает его в качестве ответа. В случае, если есть несколько слов с максимальной длиной, нужно вернуть
# слово, которое встречается последнее в тексте.
# При этом слова в тексте отделяются друг от друга пробелами, любые другие знаки пунктуации необходимо исключить.
# И также учитывайте, что слова в тестах будут как на русском языке, так и на английском
# Все возможные знаки пунктуации можно получить из модуля string

# def longest_word_in_file(file_name):
#     with open(file_name, 'r', encoding='utf-8') as f:
#         max_word = ''
#         for line in f:
#             s_word = line.split()
#             for word in s_word:
#                 word_n_punc = dell_punctuation(word)
#                 if len(word_n_punc) >= len(max_word):
#                     max_word = word_n_punc
#     return max_word
#
# def dell_punctuation(word):
#     from string import punctuation
#     for punc in punctuation:
#         if punc in word:
#             word = word.replace(punc, '')
#     return word

# print(longest_word_in_file('wordss.txt'))
##############################################
# def longest_word_in_file(file_name):
#     from string import punctuation
#
#     with open(file_name, encoding='utf-8') as f:
#         words = [*map(lambda x: x.strip(punctuation), f.read().split())]
#     return max(words[::-1], key=len)
#     # return sorted(words, key=len)[-1]
#
# print(longest_word_in_file('wordss.txt'))
##############################################
# from re import split
#
# def longest_word_in_file(filename):
#     with open(filename, 'r') as f:
#         return max(split('\W+', f.read())[:: -1], key=lambda x: len(x))

9.1 / 5
# Найти: количество трехзначных чисел;
#        сумму двухзначных чисел
# В качестве ответа укажите найденные два числа через запятую без других знаков и пробелов.
#
# def numbers3(file_name):
#     with open(file_name, 'r') as f:
#         nums_3 = [*filter(lambda x: len(x) == 3, f.read().split())]
#     return len(nums_3), numbers2(file_name)
#
# def numbers2(file_name):
#     with open(file_name, 'r') as f:
#         nums_2 = [*filter(lambda x: len(x) == 2, f.read().split())]
#         return sum(map(int, list(nums_2)))
#
# print(numbers3('numbers.txt'))
##############################################
# def s_and_n(file_name):
#     all_nums = [i for i in map(int, open(file_name))]
#     summ_2 = sum([i for i in all_nums if 9 < i < 100])
#     nums_3 = len([i for i in all_nums if 99 < i < 1000])
#     return f'{nums_3},{summ_2}'
#
# print(s_and_n('numbers.txt'))


9.3 / 2
# JSON в Python

# К вам в руки попал файл формата json, в котором содержится информация одного автосалона о продажах менеджеров.
# В файле указано для каждого менеджера список проданных им автомобилей,
# а также проставлена цена продажи каждого автомобиля.
# Ваша задача скачать файл и самостоятельно найти самого успешного менеджера по итоговой сумме продаж.
# В качестве ответа нужно через пробел указать сперва его имя, затем фамилию и после общую сумму его продаж.

# import json
# with open('manager_sales.json', 'r') as f:
#     data = json.load(f)
# max_sale = 0
# s = []
# for item in data:
#     sale = sum([i['price'] for i in item['cars']])
#     if sale > max_sale:
#         max_sale = sale
#         name = item['manager']['first_name']
#         fam = item['manager']['last_name']
# print(name, fam, max_sale)
##############################################
# import json
#
# with open('manager_sales.json', 'r') as f:
#     data = json.load(f)
# s = []
# for i in data:
#     s.append((i['manager']['first_name'], i['manager']['last_name'], sum(s['price'] for s in i['cars'])))
# print(*sorted(s, key=lambda x: -x[2])[0])

9.3 / 3
# В json-файле содержится информация о нескольких групп людей, при этом у каждой группы есть свой идентификатор.
# Ваша задача скачать файл и самостоятельно найти идентификатор группы, в которой находится самое большое количество
# женщин, рожденных после 1977 года. В качестве ответа необходимо указать через пробел идентификатор найденной группы
# и сколько в ней было женщин, рожденных после 1977 года.

# import json
# with open('group_people.json', 'r') as f:
#     sp = []
#     for inf in json.load(f):
#         sp.append((inf['id_group'], sum([1 for w in inf["people"] if w['year'] > 1977 and w['gender'] == "Female"])))
#     # print(len((sorted(sp, key=lambda x: -len(x[1]))[0])[1]))
# print(*sorted(sp, key=lambda x: x[1])[-1])
##############################################
# import json
# gr = {}
# with open("group_people.json") as f:
#     jj = json.load(f)
#     for i in jj:
#         gr[i["id_group"]] = len([j for j in i["people"] if j["gender"] == "Female" and j["year"] > 1977])
#     print(*sorted(gr.items(), key=lambda x: x[1])[-1])

9.3 / 4
# В этой задаче вам необходимо раскодировать текст, находящийся в данном текстовом файле. Ключ для декодирования
# располагается в json-файле. В качестве ответа нужно просто отправить получившийся текст.  И обратите внимание,
# что раскодировать нужно только лишь буквы, все остальные символы(цифры, знаки пунктуации и т.д.)
# необходимо выводить как есть.
#
# import json
# nothing = ''
# with open('Abracadabra.txt') as t, open('Alphabet.json') as k:
#     k_dict = json.load(k)
#     for letter in t.read():
#         if letter in k_dict:
#             nothing += k_dict[letter]
#         else:
#             nothing += letter
# print(nothing.replace('\n\n', '\n'))
##############################################
# import json
# with open('Abracadabra.txt') as t, open('Alphabet.json') as k:
#     data = json.load(k)
#     for i in t.read():
#         print(data.get(i, i), end='')
##############################################
# import json
# with open('Abracadabra.txt') as t, open('Alphabet.json') as k:
#     k_dict = json.load(k)
#     for letter in t.read():
#         if letter in k_dict:
#             print(k_dict[letter], end='')
#         else:
#             print(letter, end='')
##############################################
# import json
# with open("Alphabet.json") as f:
#     key = json.load(f)
# with open("Abracadabra.txt", encoding="utf-8") as f:
#     txt = f.read()
# print(txt.translate(txt.maketrans(key)))

9.3 / 5
# Переменная people содержит строку в формате JSON, в которой вы можете получить личные данные 100 человек.
# Каждого человека представляет предмет (словарь) с ключами: имя, страна, возраст
# Распечатку необходимо отсортировать по возрасту, а при равенстве возраста необходимо расположить в алфавитном порядке
# import json
# people = '[{"name": "Haley Whitney", "country": "British Indian Ocean Territory (Chagos Archipelago)", "age": 54},' \
#          '{"name": "Matthew King", "country": "Colombia", "age": 34}, ' \
#          '{"name": "Sean Sullivan", "country": "Mayotte", "age": 40}, ' \
#          '{"name": "Christian Crawford", "country": "Russian Federation", "age": 29}, ' \
#          '{"name": "Sarah Contreras", "country": "Honduras", "age": 82}, ' \
#          '{"name": "Danielle Williams", "country": "Togo", "age": 91}]'
# n_people = json.loads(people)
# s = []
# for i in n_people:
#     s.append((i['name'], i['country'], i['age']))
# sp = sorted(s, key=lambda x: (x[2], x[0]))
# for a, b, c in sp:
#     print(f'{a}, {b}, {c}')
##############################################
# [print(*i.values(), sep=', ') for i in sorted(json.loads(people), key=lambda x: (x['age'], x['name']))]
##############################################
# data = json.loads(people)
# data = sorted(data, key=lambda x: (x['age'], x['name']))
# for i in data:
#     # print(f"{i['name']}, {i['country']}, {i['age']}")
#     print(*i.values(), sep=', ')


10.4 / 3
# Вам дан список numbers, в нем есть и отрицательные числа и нули и положительные значения.
# Гарантируется, что список целиком состоит только из чисел.
# Необходимо при помощи функций filter и len определить сколько в этом списке отрицательных значений, сколько нулей и
# сколько положительных. Вывести найденные значения в том же порядке

# numbers = [54, 71, 65, 51, 36, -82, -32, 61, -61, 92, 17, -68, -62, 40, 16, -49, -51, -38, 60, -24, -61, 3, -26, -46,
#            -97, -28, 36, 7, 52, 56, -96, -69, 67, 76, 16, 36, 38, 74, 11, -87, 69, 69, -69, -61, 92, 67, -45, -26, 94,
#            38, 27, -26, 10, 55, 28, -81, 53, -75]
# print(len(list(filter(lambda x: x < 0, numbers))), len(list(filter(lambda x: x == 0, numbers))),
#       len(list(filter(lambda x: x > 0, numbers))))
# print(*[len(list(filter(fnc, numbers))) for fnc in [lambda x: x < 0, lambda x: x == 0, lambda x: x > 0]])
# print(*[eval(f'len(list(filter(lambda x: x {i} 0, numbers)))') for i in ['<', '==', '>']])

10.4 / 4
# Напишите программу, которая отфильтрует список days так, чтобы в нем остались только дни, названия которых состоят
# из четырех символов или начинаются с буквы S. Используйте при этом lambda функцию.
# Распечатайте получившийся список в алфавитном порядке, каждый элемент на новой строчке

# days = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve']
# print(*sorted(list(filter(lambda x: len(x) == 4 or x[0] == 'S', days))), sep='\n')


10.7 / 2
# Сортировка по ключу Python. Аргумент key
# Напишите программу, которая отсортирует список subject_marks по возрастаю оценок. Затем распечатайте предметы и
# оценки, каждый пару на новой строчке через пробел

# subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Physics', 93), ('History', 82)]
# for i in sorted(subject_marks, key=lambda x: x[1]):
#     print(*i)
# [print(*_) for _ in sorted(subject_marks, key=lambda x: x[1])]

10.7 / 3
# Напишите программу, которая отсортирует список subject_marks по убыванию оценок.
# Затем распечатайте предметы и оценки, каждый пару на новой строчке через пробел

# subject_marks = [('English', 88), ('Science', 90), ('Maths', 97),
#                  ('Physics', 93), ('History', 82), ('French', 78),
#                  ('Art', 58), ('Chemistry', 76), ('Programming', 91)]
# [print(*i) for i in sorted(subject_marks, key=lambda x: x[1])[::-1]]
# [print(*i) for i in sorted(subject_marks, key=lambda x: -x[1])]

10.7 / 4
# Напишите программу, которая отсортирует список subject_marks по убыванию оценок. Предметы, имеющих одинаковые оценки,
# должны быть отсортированы в алфавитном порядке
# Затем распечатайте предметы и оценки, каждый пару на новой строчке через пробел

# subject_marks = [('English', 88), ('Science', 90), ('Maths', 88),
#                  ('Physics', 93), ('History', 78), ('French', 78),
#                  ('Art', 78), ('Chemistry', 88), ('Programming', 91)]
# [print(*i) for i in sorted(subject_marks, key=lambda x: (-x[1], x[0]))]

10.7 / 6
# Напишите программу, которая отсортирует список models по цвету в лексикографическом порядке (по алфавиту)
# Затем распечатайте элементы этого списка, каждый элемент на новой строке в формате:
# Производитель: <make>, модель: <model>, цвет: <color>

# models = [{'make': 'Nokia', 'model': 216, 'color': 'Black'},
#           {'make': 'Mi Max', 'model': 2, 'color': 'Gold'},
#           {'make': 'Samsung', 'model': 7, 'color': 'Blue'},
#           {'make': 'Apple', 'model': 10, 'color': 'Silver'},
#           {'make': 'Oppo', 'model': 9, 'color': 'Red'},
#           {'make': 'Huawei', 'model': 4, 'color': 'Grey'},
#           {'make': 'Honor', 'model': 3, 'color': 'Black'}]
# [print((f"Производитель: {i['make']}, модель: {i['model']}, цвет: {i['color']}")) for i in
#  sorted(models, key=lambda x: x['color'])]
##############################################
# for item in sorted(models, key=lambda x: x['color']):
#     print('Производитель: {}, модель: {}, цвет: {}'.format(*item.values()))

10.7 / 7
# Представьте, у нас есть список товаров и их стоимость, но мы хотим взглянуть на него в отсортированном виде.
# Вверху хотим видеть самые дорогие товары, внизу самые дешевые.
# Программа будет принимать строки, в которых сперва указывается название товара, а затем через двоеточие с пробелом
# его цена - целое положительное число.
# Строка "конец" означает списка товаров и соответственно окончание ввода
# Все товары имеют уникальные названия, цены не дублируются.
# Ваша задача вывести список товаров по уменьшению цены

# '''Sony PlayStation 5: 46000
# Телевизор QLED Samsung QE65Q60TAU: 87090
# Смартфон Samsung Galaxy A11: 10000
# Планшет Samsung Galaxy Tab S6: 26600
# конец'''
# s = [i.split(': ') for i in iter(input, 'конец')]
# [print(i[0]) for i in sorted(s, key=lambda x: -int(x[1]))]
##############################################
# [print(i[0]) for i in sorted([i.split(': ') for i in iter(input, 'конец')], key=lambda x: -int(x[1]))]
##############################################
# d = {}
# while True:
#     s = input()
#     if s == 'конец':
#         break
#     else:
#         a, b = s.split(': ')
#         d[a] = int(b)
# d = sorted(d, key=d.get, reverse=True)
# print(*d, sep='\n')

10.7 / 8
# Премия Оскар

# Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет.
# Написать программу, которая находит информацию, кто из актеров получил наибольшее и наименьшее количество статуэток
# Программа принимает на вход в первой строке натуральное число n - количество вручаемых сегодня наград.
# Затем в n следующих строках вводятся имена актеров - победителей.
# Вывести в отдельных строках имена актеров набравших наибольшее и наименьшее количество статуэток
# и через запятую их количество. Гарантируется, что всегда будет только один человек, набравших наибольшее
# и наименьшее количество статуэток.

# d = {}
# for i in range(int(input())):
#     name = input()
#     d[name] = d.get(name, 0) + 1
# print(d)
# d = sorted(d.items(), key=lambda x: (-x[1], x[0]))
# print(*d[0], sep=', ')
# print(*d[-1], sep=', ')
##############################################
# from collections import Counter
# d = dict(Counter(input() for i in range(int(input()))))
# print(d)
# d = sorted(d.items(), key=lambda x: (-x[1], x[0]))
# print(*d[0], sep=', ')
# print(*d[-1], sep=', ')
##############################################
# l = [input() for i in range(int(input()))]
# x = list(sorted(l, key=l.count)[::-1])
# print(f'{x[0]}, {x.count(x[0])}\n{x[-1]}, {x.count(x[-1])}')
##############################################
# from collections import Counter
# d = Counter([input() for _ in range(int(input()))])
# d = sorted(d.items(), key=lambda x: (-x[1], x[0]))
# print('%s, %d\n%s, %d' % (d[0][0], d[0][1], d[-1][0], d[-1][1]))

10.7 / 9
# Телефонная книга

# Петя очень популярный парень, у него много друзей и он хочет сохранить их контакты в телефонной книге. Известно, что
# у каждого друга может быть один или больше номеров телефонов. Напишите программу, которая поможет Пете находить все
# номера определённого друга.
# В первой строке задано число — количество номеров телефонов, информацию о которых Петя решил сохранить.
# В следующих N строках заданы телефоны и имена их владельцев через пробел.
# Телефон — это несколько цифр, записанных подряд, имя же состоит только из русских букв. Записи не повторяются.
# В следующей строке записано число M — количество запросов от Пети.
# В следующих M строках записаны запросы, по одному на строке. Каждый запрос — имя какого-то друга,
# чьи телефоны Петя хочет сейчас найти.
# Для каждого запроса от Пети, выведите в отдельной строке все телефоны, принадлежащие человеку с этим именем.
# Телефоны 1 человека выводите в одну строку через пробел в том порядке, в котором они были заданы во входных данных.
# Если в телефонной книге нет телефонов человека с таким именем, выведите «Неизвестный номер» (без кавычек).

# Sample Input:
# 2 // 444444 Женя // 79129874521 Женя
# 2 // Олег // Женя
# Sample Output:
# Неизвестный номер // 444444 79129874521

# d = {}
# for _ in range(int(input())):
#     number, name = input().split()
#     d.setdefault(name, []).append(number)
# for _ in range(int(input())):
#     print(*d.get(input(), ['Неизвестный номер']))
##############################################
# d = {}
# for _ in range(int(input())):
#     number, name = input().split()
#     d[name] = d.get(name, []) + [number]
# [print(*d.get(input(), ['Неизвестный номер'])) for i in range(int(input()))]

10.7 / 10
# Дни рождения

# У Игоря N одноклассников. Игорь не смог запомнить их дни рождения и решил составить календарь дней рождений класса.
# По известному списку всех дней рождения научитесь определять, у кого день рождения в заданном месяце.

# В первой строчке записано N одноклассников Игоря. В следующих N строчках записана информация об их днях рождения.
# Каждая строчка состоит из трёх частей, разделённых пробелом — имени, дня и месяца его рождения.
# Имена всех одноклассников Игоря различны.
# В следующей строчке записано M вопросов, на которое надо ответить.
# В следующих M строках содержатся сами вопросы. Вопрос — это название месяца в том же формате,
# Через пробел выведите имена всех одноклассников, которые родились в указанном месяце. Имена упорядочьте в
# лексикографическом порядке. Если в заданном месяце никто не родился, выведите сообщение "Нет данных".

# '''4
# Саша 20 янв
# Артем 15 июн
# Карл 10 янв
# Коля 20 июл
# 2
# янв
# дек
# '''

# d = {}
# for _ in range(int(input())):
#     name, day, month = input().split()
#     d.setdefault(month, []).append(name)
# [print(*sorted(d.get(input(), ['Нет данных']))) for i in range(int(input()))]

10.7 / 11


# Рейтинг таксистов

# Руководитель таксопарка хочет увидеть отчет по всем таксистам, где нужно указать имя таксиста и его среднюю оценку.
# Информацию в отчете нужно расположить по убыванию средней оценки таксиста.
# После каждого успешно выполненного заказа, клиент выставляет таксисту оценку - целое число от 1 до 5.
# Строка "конец" является последней строкой и означает окончание ввода
# Нужно расположить таксистов в порядке убывания их средней оценке и вывести имя каждого таксиста и его среднюю оценку
# в отдельной строке.
# В случае совпадения средних оценок расположить таксистов нужно отсортировать имена таксистов по алфавиту

# d = {}
# for i in iter(input, 'конец'):
#     name, number = i.split(', ')
#     d.setdefault(name, []).append(int(number))
# for key in sorted(sorted(d), reverse=True, key=lambda x: sum(d[x]) / len(d[x])):
#     print(key, (sum(d[key]) / len(d[key])))
##############################################
# for key in d:
#     d[key] = sum(d[key]) / len(d[key])
# d = sorted(d.items(), key=lambda i: (-i[1], i[0]))
# for rating in d:
#     print(*rating)
##############################################
# for name, rank in sorted({k: sum(v) / len(v) for k, v in d.items()}.items(), key=lambda x: (-x[1], x[0])):
#     print(name, rank)
##############################################
# [print(*j) for j in sorted([[d, sum(gs)/len(gs)] for d, gs in d.items()], key=lambda k: (-k[1], k[0]))]



##############################################
##############################################
# def create(namespace, parent):
#     info.update({namespace: [parent]})
#
#
# def add(namespace, var):
#     info[namespace].append(var)
#
#
# def get(namespace, var):
#     while namespace != None and var not in info[namespace][1:]:
#         namespace = info[namespace][0]
#         print(namespace)
#
#
# operations = {'create': create, 'add': add, 'get': get}
# info = {'global': [None]}
# for _ in range(int(input())):
#     cmd, ns, var = input().split()
#     operations[cmd](ns, var)
# print(info)